<!DOCTYPE HTML>
<!-- saved from url=(0039)http://nodejs.cn/api/child_process.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cmn-Hans"><HEAD><META 
content="IE=11.0000" http-equiv="X-UA-Compatible">
   
<META charset="utf-8">   <TITLE>child_process | Node.js API 文档</TITLE>   <LINK 
href="child_process%20%20Node_js%20API%20文档_files/api.css" rel="stylesheet">   
<LINK href="/static/favicon.png" rel="icon" type="image/png" sizes="32x32"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18639"></HEAD> 
<BODY class="alt apidoc" id="api-section-child_process">
<DIV class="clearfix" id="content">
<DIV class="interior" id="column2">
<DIV class="interior" id="intro"><A href="http://nodejs.cn/">          Node.js 
中文网         </A>         
<DIV><INPUT id="search_input" placeholder="API 快速搜索" value="">         
</DIV></DIV>
<UL>
  <LI><A class="nav-documentation" href="http://nodejs.cn/api/documentation.html">关于本文档</A></LI>
  <LI><A class="nav-synopsis" 
  href="http://nodejs.cn/api/synopsis.html">用法与例子</A></LI></UL>
<DIV class="line"></DIV>
<UL>
  <LI><A class="nav-assert" href="http://nodejs.cn/api/assert.html">Assert 
  (断言)</A></LI>
  <LI><A class="nav-buffer" 
  href="http://nodejs.cn/api/buffer.html">Buffer</A></LI>
  <LI><A class="nav-addons" href="http://nodejs.cn/api/addons.html">C/C++ 
  插件</A></LI>
  <LI><A class="nav-child_process active" href="http://nodejs.cn/api/child_process.html">Child 
  Processes (子进程)</A></LI>
  <LI><A class="nav-cluster" href="http://nodejs.cn/api/cluster.html">Cluster 
  (集群)</A></LI>
  <LI><A class="nav-cli" href="http://nodejs.cn/api/cli.html">CLI 
  (命令行选项)</A></LI>
  <LI><A class="nav-console" href="http://nodejs.cn/api/console.html">Console 
  (控制台)</A></LI>
  <LI><A class="nav-crypto" href="http://nodejs.cn/api/crypto.html">Crypto 
  (加密)</A></LI>
  <LI><A class="nav-debugger" href="http://nodejs.cn/api/debugger.html">Debugger 
  (调试器)</A></LI>
  <LI><A class="nav-dns" href="http://nodejs.cn/api/dns.html">DNS 
  (域名服务器)</A></LI>
  <LI><A class="nav-domain" href="http://nodejs.cn/api/domain.html">Domain 
  (域)</A></LI>
  <LI><A class="nav-errors" href="http://nodejs.cn/api/errors.html">Error 
  (错误)</A></LI>
  <LI><A class="nav-events" href="http://nodejs.cn/api/events.html">Events 
  (事件)</A></LI>
  <LI><A class="nav-fs" href="http://nodejs.cn/api/fs.html">File System 
  (文件系统)</A></LI>
  <LI><A class="nav-globals" href="http://nodejs.cn/api/globals.html">Global 
  (全局变量)</A></LI>
  <LI><A class="nav-http" href="http://nodejs.cn/api/http.html">HTTP</A></LI>
  <LI><A class="nav-https" href="http://nodejs.cn/api/https.html">HTTPS</A></LI>
  <LI><A class="nav-modules" href="http://nodejs.cn/api/modules.html">Module 
  (模块)</A></LI>
  <LI><A class="nav-net" href="http://nodejs.cn/api/net.html">Net (网络)</A></LI>
  <LI><A class="nav-os" href="http://nodejs.cn/api/os.html">OS (操作系统)</A></LI>
  <LI><A class="nav-path" href="http://nodejs.cn/api/path.html">Path 
  (路径)</A></LI>
  <LI><A class="nav-process" href="http://nodejs.cn/api/process.html">Process 
  (进程)</A></LI>
  <LI><A class="nav-punycode" 
  href="http://nodejs.cn/api/punycode.html">Punycode</A></LI>
  <LI><A class="nav-querystring" 
  href="http://nodejs.cn/api/querystring.html">Query Strings (查询字符串)</A></LI>
  <LI><A class="nav-readline" href="http://nodejs.cn/api/readline.html">Readline 
  (逐行读取)</A></LI>
  <LI><A class="nav-repl" href="http://nodejs.cn/api/repl.html">REPL 
  (交互式解释器)</A></LI>
  <LI><A class="nav-stream" href="http://nodejs.cn/api/stream.html">Stream 
  (流)</A></LI>
  <LI><A class="nav-string_decoder" href="http://nodejs.cn/api/string_decoder.html">String 
  Decoder (字符串解码器)</A></LI>
  <LI><A class="nav-timers" href="http://nodejs.cn/api/timers.html">Timer 
  (定时器)</A></LI>
  <LI><A class="nav-tls" href="http://nodejs.cn/api/tls.html">TLS 
  (安全传输层)</A></LI>
  <LI><A class="nav-tty" href="http://nodejs.cn/api/tty.html">TTY (终端)</A></LI>
  <LI><A class="nav-dgram" href="http://nodejs.cn/api/dgram.html">UDP/Datagram 
  (数据报)</A></LI>
  <LI><A class="nav-url" href="http://nodejs.cn/api/url.html">URL</A></LI>
  <LI><A class="nav-util" href="http://nodejs.cn/api/util.html">Util 
  (实用工具)</A></LI>
  <LI><A class="nav-v8" href="http://nodejs.cn/api/v8.html">V8</A></LI>
  <LI><A class="nav-vm" href="http://nodejs.cn/api/vm.html">VM (虚拟机)</A></LI>
  <LI><A class="nav-zlib" href="http://nodejs.cn/api/zlib.html">ZLIB 
  (压缩)</A></LI></UL>
<DIV class="line"></DIV></DIV>
<DIV class="interior" id="column1" data-id="child_process"><HEADER>
<H1>Node.js v6.10.3 文档</H1>
<DIV id="gtoc">
<P><A name="toc" href="http://nodejs.cn/api/">返回文档首页</A>             <!--<a href="/api/all.html">单页面显示</a> |--> 
            <!--<a href="/api/child_process.json">JSON格式</a> |-->             <!--<a href="/api/en/child_process.html">查看英文版</a>--> 
          </P></DIV>
<HR>
</HEADER>
<DIV id="toc">
<H2>目录</H2>
<UL>
  <LI><SPAN class="stability_2"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process">child_process 
  (子进程)</A></SPAN>
  <UL> 
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_asynchronous_process_creation">创建异步进程</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows">在 
      Windows 上衍生 <CODE>.bat</CODE> 和 <CODE>.cmd</CODE> 文件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback">child_process.exec(command[, 
      options][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback">child_process.execFile(file[, 
      args][, options][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options">child_process.fork(modulePath[, 
      args][, options])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options">child_process.spawn(command[, 
      args][, options])</A></SPAN>
      <UL> 
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_options_detached">options.detached</A></SPAN></LI>
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio">options.stdio</A></SPAN></LI></UL></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_synchronous_process_creation">创建同步进程</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfilesync_file_args_options">child_process.execFileSync(file[, 
      args][, options])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execsync_command_options">child_process.execSync(command[, 
      options])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options">child_process.spawnSync(command[, 
      args][, options])</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">ChildProcess 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_event_close">'close' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_event_disconnect">'disconnect' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_event_error">'error' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_event_exit">'exit' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_event_message">'message' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_connected">child.connected</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_disconnect">child.disconnect()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_kill_signal">child.kill([signal])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_pid">child.pid</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_send_message_sendhandle_options_callback">child.send(message[, 
      sendHandle[, options]][, callback])</A></SPAN>
      <UL> 
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_example_sending_a_server_object">例子：发送一个 
        server 对象</A></SPAN></LI>
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_example_sending_a_socket_object">例子：发送一个 
        socket 对象</A></SPAN></LI></UL></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_stderr">child.stderr</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_stdin">child.stdin</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_stdio">child.stdio</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_child_stdout">child.stdout</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE> 
    与 Unicode</A></SPAN></LI></UL></LI></UL></DIV>
<DIV id="apicontent">
<H1>child_process (子进程)<SPAN><A class="mark" id="child_process_child_process" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process">#</A></SPAN></H1>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_2"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 2</A> - 稳定的</PRE>
<P><CODE>child_process</CODE> 模块提供了衍生子进程的能力，它与 <A href="http://man7.org/linux/man-pages/man3/popen.3.html">popen(3)</A> 
类似，但不完全相同。 这个能力主要由 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
函数提供：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) =&gt; {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) =&gt; {
  console.log(`stderr: ${data}`);
});

ls.on('close', (code) =&gt; {
  console.log(`子进程退出码：${code}`);
});
</CODE></PRE>
<P>默认情况下，在 Node.js 的父进程和衍生的子进程之间会建立 <CODE>stdin</CODE>、<CODE>stdout</CODE> 和 
<CODE>stderr</CODE> 的管道。 这使得数据可以以非阻塞的方式在这些管道流通。 注意，有些程序会在内部使用行缓冲 I/O。 虽然这并不影响 
Node.js，但这意味着发送到子过程的数据可能无法被立即消费。</P>
<P><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
方法会异步地衍生子进程，且不会阻塞 Node.js 的事件循环。 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A> 
函数则以同步的方式提供了同样的功能，但会阻塞事件循环，直到衍生的子进程退出或终止。</P>
<P>为了方便起见，<CODE>child_process</CODE> 模块提供了一些同步和异步的替代方法用于  <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A>。
 注意，每个替代方法都是在 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
或 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A> 
的基础上实现的。</P>
<UL>
  <LI><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A>: 
  衍生一个 shell 并在 shell 上运行一个命令，当完成时会传入 <CODE>stdout</CODE> 和 <CODE>stderr</CODE> 
  到一个回调。</LI>
  <LI><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A>: 
  和  <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
  类似，除了它直接衍生命令，且不用先衍生一个 shell。</LI>
  <LI><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A>: 
  衍生一个新的 Node.js 进程，并通过建立一个允许父进程和子进程之间相互发送信息的 IPC 通讯通道来调用一个指定的模块。</LI>
  <LI><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execsync_command_options"><CODE>child_process.execSync()</CODE></A>: 
  <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
  的一个同步版本，它会阻塞 Node.js 的事件循环。</LI>
  <LI><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfilesync_file_args_options"><CODE>child_process.execFileSync()</CODE></A>: 
  <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
  的一个同步版本，它会阻塞 Node.js 的事件循环。</LI></UL>
<P>对于某些用例，如自动化的 shell 脚本，<A href="http://nodejs.cn/api/child_process.html#child_process_synchronous_process_creation">同步的版本</A>可能更方便。
 大多数情况下，同步的方法会显著地影响性能，因为它拖延了事件循环直到衍生进程完成。</P>
<H2>创建异步进程<SPAN><A class="mark" id="child_process_asynchronous_process_creation" 
href="http://nodejs.cn/api/child_process.html#child_process_asynchronous_process_creation">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_asynchronous_process_creation">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/asynchronous_process_creation.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A>、<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A>、<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
方法都遵循与其他 Node.js API 一样的惯用的异步编程模式。</P>
<P>每个方法都返回一个 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
实例。 这些对象实现了 Node.js <A href="http://nodejs.cn/api/events.html#events_class_eventemitter"><CODE>EventEmitter</CODE></A> 
的 API，允许父进程注册监听器函数，在子进程生命周期期间，当特定的事件发生时会调用这些函数。</P>
<P><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
返回可以额外指定一个可选的 <CODE>callback</CODE> 函数，当子进程结束时会被调用。</P>
<H3>在 Windows 上衍生 <CODE>.bat</CODE> 和 <CODE>.cmd</CODE> 文件<SPAN><A class="mark" 
id="child_process_spawning_bat_and_cmd_files_on_windows" href="http://nodejs.cn/api/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_spawning_bat_and_cmd_files_on_windows">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/spawning_bat_and_cmd_files_on_windows.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
之间的重大区别会根据平台的不同而不同。 在类 Unix 操作系统上（Unix、 Linux、 OSX），<A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
效率更高，因为它不需要衍生一个 shell。 但是在 Windows 上，<CODE>.bat</CODE> 和 <CODE>.cmd</CODE> 
文件在没有终端的情况下是不可执行的，因此不能使用 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
启动。 当在 Windows 下运行时，要调用 <CODE>.bat</CODE> 和 <CODE>.cmd</CODE> 文件，可以通过使用设置了 
<CODE>shell</CODE> 选项的 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A>、或使用 
<A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A>、或衍生 
<CODE>cmd.exe</CODE> 并将 <CODE>.bat</CODE> 或 <CODE>.cmd</CODE> 文件作为一个参数传入（也就是 
<CODE>shell</CODE> 选项和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
所做的工作）。 在任何情况下，如果脚本文件名包含了空格，则需要用加上引号。</P>
<PRE><CODE class="lang-js">// 仅限 Windows 系统
const spawn = require('child_process').spawn;
const bat = spawn('cmd.exe', ['/c', 'my.bat']);

bat.stdout.on('data', (data) =&gt; {
  console.log(data.toString());
});

bat.stderr.on('data', (data) =&gt; {
  console.log(data.toString());
});

bat.on('exit', (code) =&gt; {
  console.log(`子进程退出码：${code}`);
});

// 或
const exec = require('child_process').exec;
exec('my.bat', (err, stdout, stderr) =&gt; {
  if (err) {
    console.error(err);
    return;
  }
  console.log(stdout);
});

// 文件名带有空格的脚本：
const bat = spawn('"my script.cmd"', ['a', 'b'], { shell: true });
// 或：
exec('"my script.cmd" a b', (err, stdout, stderr) =&gt; {
  // ...
});
</CODE></PRE>
<H3>child_process.exec(command[, options][, callback])<SPAN><A class="mark" id="child_process_child_process_exec_command_options_callback" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_exec_command_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_exec_command_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>command</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的命令，用空格分隔参数</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    （默认: <CODE>'utf8'</CODE>）</LI>
    <LI><CODE>shell</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于执行命令的 shell （默认：在 UNIX 上为 <CODE>'/bin/sh'</CODE>，在 Windows 上为 
    <CODE>'cmd.exe'</CODE>。 该 shell 应该能够理解 UNIX 的 <CODE>-c</CODE> 开关或 Windows 的 
    <CODE>/s /c</CODE> 开关。 在 Windows 中，命令行的解析应与 <CODE>cmd.exe</CODE> 兼容。）</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    （默认: <CODE>0</CODE>）</LI>
    <LI><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE></A> 
    <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    stdout 或 stderr 允许的最大数据量（以字节为单位）。
     如果超过限制，则子进程会被终止。（默认：<CODE>200*1024</CODE>）</LI>
    <LI><CODE>killSignal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    （默认: <CODE>'SIGTERM'</CODE>）</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI></UL></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  当进程终止时调用，并带上输出。
  <UL>
    <LI><CODE>error</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A></LI>
    <LI><CODE>stdout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
    <LI><CODE>stderr</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</A></LI></UL>
<P>衍生一个 shell，然后在 shell 中执行 <CODE>command</CODE>，且缓冲任何产生的输出。</P>
<P>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</P>
<PRE><CODE class="lang-js">const exec = require('child_process').exec;
exec('cat *.js bad_file | wc -l', (error, stdout, stderr) =&gt; {
  if (error) {
    console.error(`exec error: ${error}`);
    return;
  }
  console.log(`stdout: ${stdout}`);
  console.log(`stderr: ${stderr}`);
});
</CODE></PRE>
<P>如果提供了一个 <CODE>callback</CODE> 函数，则它被调用时会带上参数 <CODE>(error, stdout, 
stderr)</CODE>。 当成功时，<CODE>error</CODE> 会是 <CODE>null</CODE>。
 当失败时，<CODE>error</CODE> 会是一个 <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A> 
实例。 <CODE>error.code</CODE> 属性会是子进程的退出码，<CODE>error.signal</CODE> 会被设为终止进程的信号。 除 
<CODE>0</CODE> 以外的任何退出码都被认为是一个错误。</P>
<P>传给回调的 <CODE>stdout</CODE> 和 <CODE>stderr</CODE> 参数会包含子进程的 stdout 和 stderr 
的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 <CODE>encoding</CODE> 选项可用于指定用于解码 
stdout 和 stderr 输出的字符编码。 如果 <CODE>encoding</CODE> 是 
<CODE>'buffer'</CODE>、或一个无法识别的字符编码，则传入 <CODE>Buffer</CODE> 对象到回调函数。</P>
<P><CODE>options</CODE> 参数可以作为第二个参数传入，用于自定义如何衍生进程。 默认的选项是：</P>
<PRE><CODE class="lang-js">{
  encoding: 'utf8',
  timeout: 0,
  maxBuffer: 200*1024,
  killSignal: 'SIGTERM',
  cwd: null,
  env: null
}
</CODE></PRE>
<P>如果 <CODE>timeout</CODE> 大于 <CODE>0</CODE>，当子进程运行超过 <CODE>timeout</CODE> 
毫秒时，父进程就会发送由 <CODE>killSignal</CODE> 属性标识的信号（默认为 <CODE>'SIGTERM'</CODE>）。</P>
<P>注意：不像 POSIX 系统调用中的 <A 
href="http://man7.org/linux/man-pages/man3/exec.3.html">exec(3)</A>，<CODE>child_process.exec()</CODE> 
不会替换现有的进程，且使用一个 shell 来执行命令。</P>
<H3>child_process.execFile(file[, args][, options][, callback])<SPAN><A class="mark" 
id="child_process_child_process_execfile_file_args_options_callback" href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_execfile_file_args_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_execfile_file_args_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.91</SPAN> </DIV>
<UL>
  <LI><CODE>file</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的可执行文件的名称或路径</LI>
  <LI><CODE>args</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
  字符串参数列表</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    （默认: <CODE>'utf8'</CODE>）</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    （默认: <CODE>0</CODE>）</LI>
    <LI><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE></A> 
    <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    stdout 或 stderr 允许的最大数据量（以字节为单位）。
     如果超过限制，则子进程会被终止。（默认：<CODE>200*1024</CODE>）</LI>
    <LI><CODE>killSignal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    （默认: <CODE>'SIGTERM'</CODE>）</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI></UL></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  当进程终止时调用，并带上输出。
  <UL>
    <LI><CODE>error</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A></LI>
    <LI><CODE>stdout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
    <LI><CODE>stderr</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</A></LI></UL>
<P><CODE>child_process.execFile()</CODE> 函数类似 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A>，除了不衍生一个 
shell。 而是，指定的可执行的 <CODE>file</CODE> 被直接衍生为一个新进程，这使得它比 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
更高效。</P>
<P>它支持和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
一样的选项。 由于没有衍生 shell，因此不支持像 I/O 重定向和文件查找这样的行为。</P>
<PRE><CODE class="lang-js">const execFile = require('child_process').execFile;
const child = execFile('node', ['--version'], (error, stdout, stderr) =&gt; {
  if (error) {
    throw error;
  }
  console.log(stdout);
});
</CODE></PRE>
<P>传给回调的 <CODE>stdout</CODE> 和 <CODE>stderr</CODE> 参数会包含子进程的 stdout 和 stderr 
的输出。 默认情况下，Node.js 会解码输出为 UTF-8，并将字符串传给回调。 <CODE>encoding</CODE> 选项可用于指定用于解码 
stdout 和 stderr 输出的字符编码。 如果 <CODE>encoding</CODE> 是 
<CODE>'buffer'</CODE>、或一个无法识别的字符编码，则传入 <CODE>Buffer</CODE> 对象到回调函数。</P>
<H3>child_process.fork(modulePath[, args][, options])<SPAN><A class="mark" id="child_process_child_process_fork_modulepath_args_options" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_fork_modulepath_args_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_fork_modulepath_args_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.0</SPAN> </DIV>
<UL>
  <LI><CODE>modulePath</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要在子进程中运行的模块</LI>
  <LI><CODE>args</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
  字符串参数列表</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>execPath</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用来创建子进程的执行路径</LI>
    <LI><CODE>execArgv</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    要传给执行路径的字符串参数列表 （默认: <CODE>process.execArgv</CODE>）</LI>
    <LI><CODE>silent</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    如果为 <CODE>true</CODE>，则子进程中的 stdin、 stdout 和 stderr 会被导流到父进程中，否则它们会继承自父进程，详见 
    <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
    的 <A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><CODE>stdio</CODE></A> 
    中的 <CODE>'pipe'</CODE> 和 <CODE>'inherit'</CODE> 选项。 （默认: 
    <CODE>false</CODE>）</LI>
    <LI><CODE>stdio</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    支持 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
    的 <A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><CODE>stdio</CODE></A> 
    选项的数组版本。 当提供了该选项，则它会覆盖 <CODE>silent</CODE>。 该数组必须包含一个值为 <CODE>'ipc'</CODE> 
    的子项，否则会抛出错误。 例如 <CODE>[0, 1, 2, 'ipc']</CODE>。</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</A></LI></UL>
<P><CODE>child_process.fork()</CODE> 方法是 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
的一个特殊情况，专门用于衍生新的 Node.js 进程。 跟 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
一样返回一个 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
对象。 返回的 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
会有一个额外的内置的通信通道，它允许消息在父进程和子进程之间来回传递。 详见 <A href="http://nodejs.cn/api/child_process.html#child_process_child_send_message_sendhandle_options_callback"><CODE>child.send()</CODE></A>。</P>
<P>衍生的 Node.js 子进程与两者之间建立的 IPC 通信信道的异常是独立于父进程的。 每个进程都有自己的内存，使用自己的 V8 实例。
 由于需要额外的资源分配，因此不推荐衍生大量的 Node.js 进程。</P>
<P>默认情况下，<CODE>child_process.fork()</CODE> 会使用父进程中的 <A href="http://nodejs.cn/api/process.html#process_process_execpath"><CODE>process.execPath</CODE></A> 
衍生新的 Node.js 实例。 <CODE>options</CODE> 对象中的 <CODE>execPath</CODE> 
属性可以替换要使用的执行路径。</P>
<P>使用自定义的 <CODE>execPath</CODE> 启动的 Node.js 进程，会使用子进程的环境变量 
<CODE>NODE_CHANNEL_FD</CODE> 中指定的文件描述符（fd）与父进程通信。 fd 上的输入和输出期望被分割成一行一行的 JSON 
对象。</P>
<P>注意，不像 POSIX 系统回调中的 <A 
href="http://man7.org/linux/man-pages/man2/fork.2.html">fork(2)</A>，<CODE>child_process.fork()</CODE> 
不会克隆当前进程。</P>
<H3>child_process.spawn(command[, args][, options])<SPAN><A class="mark" id="child_process_child_process_spawn_command_args_options" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_spawn_command_args_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_spawn_command_args_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>command</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的命令</LI>
  <LI><CODE>args</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
  字符串参数列表</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>argv0</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    显式地设置要发给子进程的 <CODE>argv[0]</CODE> 的值。 如果未指定，则设为 <CODE>command</CODE>。</LI>
    <LI><CODE>stdio</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的 stdio 配置。 （详见 <A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><CODE>options.stdio</CODE></A>）</LI>
    <LI><CODE>detached</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    准备将子进程独立于父进程运行。 具体行为取决于平台。（详见 <A href="http://nodejs.cn/api/child_process.html#child_process_options_detached"><CODE>options.detached</CODE></A>）</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI>
    <LI><CODE>shell</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    如果为 <CODE>true</CODE>，则在一个 shell 中运行 <CODE>command</CODE>。 在 UNIX 上使用 
    <CODE>'/bin/sh'</CODE>，在 Windows 上使用 <CODE>'cmd.exe'</CODE>。 一个不同的 shell 
    可以被指定为字符串。 该 shell 应该理解 UNIX 上的 <CODE>-c</CODE> 开关、或 Windows 的 <CODE>/s 
    /c</CODE>。 默认为 <CODE>false</CODE>（没有 shell）。</LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">&lt;ChildProcess&gt;</A></LI></UL>
<P><CODE>child_process.spawn()</CODE> 方法使用给定的 <CODE>command</CODE> 和 
<CODE>args</CODE> 中的命令行参数来衍生一个新进程。 如果省略 <CODE>args</CODE>，则默认为一个空数组。</P>
<P>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</P>
<P>第三个参数可以用来指定额外的选项，默认如下：</P>
<PRE><CODE class="lang-js">{
  cwd: undefined,
  env: process.env
}
</CODE></PRE>
<P>使用 <CODE>cwd</CODE> 来指定衍生的进程的工作目录。 如果没有给出，则默认继承当前的工作目录。</P>
<P>使用 <CODE>env</CODE> 来指定环境变量，这会在新进程中可见，默认为 <A href="http://nodejs.cn/api/process.html#process_process_env"><CODE>process.env</CODE></A>。</P>
<P>例子，运行 <CODE>ls -lh /usr</CODE>，捕获 
<CODE>stdout</CODE>、<CODE>stderr</CODE>、以及退出码：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const ls = spawn('ls', ['-lh', '/usr']);

ls.stdout.on('data', (data) =&gt; {
  console.log(`stdout: ${data}`);
});

ls.stderr.on('data', (data) =&gt; {
  console.log(`stderr: ${data}`);
});

ls.on('close', (code) =&gt; {
  console.log(`子进程退出码：${code}`);
});
</CODE></PRE>
<P>例子，一种执行 <CODE>'ps ax | grep ssh'</CODE> 的方法：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const ps = spawn('ps', ['ax']);
const grep = spawn('grep', ['ssh']);

ps.stdout.on('data', (data) =&gt; {
  grep.stdin.write(data);
});

ps.stderr.on('data', (data) =&gt; {
  console.log(`ps stderr: ${data}`);
});

ps.on('close', (code) =&gt; {
  if (code !== 0) {
    console.log(`ps 进程退出码：${code}`);
  }
  grep.stdin.end();
});

grep.stdout.on('data', (data) =&gt; {
  console.log(data.toString());
});

grep.stderr.on('data', (data) =&gt; {
  console.log(`grep stderr: ${data}`);
});

grep.on('close', (code) =&gt; {
  if (code !== 0) {
    console.log(`grep 进程退出码：${code}`);
  }
});
</CODE></PRE>
<P>例子，检测失败的执行：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const child = spawn('bad_command');

child.on('error', (err) =&gt; {
  console.log('启动子进程失败。');
});
</CODE></PRE>
<P>注意：某些平台（OS X, Linux）会使用 <CODE>argv[0]</CODE> 的值作为进程的标题，而其他平台（Windows, 
SunOS）则使用 <CODE>command</CODE>。</P>
<P>注意，Node.js 一般会在启动时用 <CODE>process.execPath</CODE> 重写 <CODE>argv[0]</CODE>，所以 
Node.js 子进程中的 <CODE>process.argv[0]</CODE> 不会匹配从父进程传给 <CODE>spawn</CODE> 的 
<CODE>argv0</CODE> 参数，可以使用 <CODE>process.argv0</CODE> 属性获取它。</P>
<H4>options.detached<SPAN><A class="mark" id="child_process_options_detached" 
href="http://nodejs.cn/api/child_process.html#child_process_options_detached">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_options_detached">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/options_detached.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.10</SPAN> </DIV>
<P>在 Windows 上，设置 <CODE>options.detached</CODE> 为 <CODE>true</CODE> 
可以使子进程在父进程退出后继续运行。 子进程有自己的控制台窗口。 一旦启用一个子进程，它将不能被禁用。</P>
<P>在非 Windows 平台上，如果将 <CODE>options.detached</CODE> 设为 
<CODE>true</CODE>，则子进程会成为新的进程组和会话的领导者。 注意，子进程在父进程退出后可以继续运行，不管它们是否被分离。 详见 <A 
href="http://man7.org/linux/man-pages/man2/setsid.2.html">setsid(2)</A>。</P>
<P>默认情况下，父进程会等待被分离的子进程退出。 为了防止父进程等待给定的 <CODE>child</CODE>，可以使用 
<CODE>child.unref()</CODE> 方法。
 这样做会导致父进程的事件循环不包含子进程的引用计数，使得父进程独立于子进程退出，除非子进程和父进程之间建立了一个 IPC 信道。</P>
<P>当使用 <CODE>detached</CODE> 选项来启动一个长期运行的进程时，该进程不会在父进程退出后保持在后台运行，除非提供了一个不连接到父进程的 
<CODE>stdio</CODE> 配置。 如果父进程的 <CODE>stdio</CODE> 是继承的，则子进程会保持连接到控制终端。</P>
<P>例子，一个长期运行的进程，为了忽视父进程的终止，通过分离且忽视其父进程的 <CODE>stdio</CODE> 文件描述符来实现：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;

const child = spawn(process.argv[0], ['child_program.js'], {
  detached: true,
  stdio: 'ignore'
});

child.unref();
</CODE></PRE>
<P>也可以将子进程的输出重定向到文件：</P>
<PRE><CODE class="lang-js">const fs = require('fs');
const spawn = require('child_process').spawn;
const out = fs.openSync('./out.log', 'a');
const err = fs.openSync('./out.log', 'a');

const child = spawn('prg', [], {
  detached: true,
  stdio: [ 'ignore', out, err ]
});

child.unref();
</CODE></PRE>
<H4>options.stdio<SPAN><A class="mark" id="child_process_options_stdio" href="http://nodejs.cn/api/child_process.html#child_process_options_stdio">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_options_stdio">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/options_stdio.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.10</SPAN> </DIV>
<P><CODE>options.stdio</CODE> 选项用于配置子进程与父进程之间建立的管道。 默认情况下，子进程的 stdin、 stdout 和 
stderr 会重定向到 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
对象上相应的 <A href="http://nodejs.cn/api/child_process.html#child_process_child_stdin"><CODE>child.stdin</CODE></A>、 
<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_stdout"><CODE>child.stdout</CODE></A> 
和 <A 
href="http://nodejs.cn/api/child_process.html#child_process_child_stderr"><CODE>child.stderr</CODE></A> 
流。 这等同于将 <CODE>options.stdio</CODE> 设为 <CODE>['pipe', 'pipe', 
'pipe']</CODE>。</P>
<P>为了方便起见，<CODE>options.stdio</CODE> 可以是以下字符串之一：</P>
<UL>
  <LI><CODE>'pipe'</CODE> - 等同于 <CODE>['pipe', 'pipe', 'pipe']</CODE> （默认）</LI>
  <LI><CODE>'ignore'</CODE> - 等同于 <CODE>['ignore', 'ignore', 
  'ignore']</CODE></LI>
  <LI><CODE>'inherit'</CODE> - 等同于 <CODE>[process.stdin, process.stdout, 
  process.stderr]</CODE> 或 <CODE>[0,1,2]</CODE></LI></UL>
<P>另外，<CODE>option.stdio</CODE> 的值是一个每个索引都对应一个子进程 fd 的数组。 fd 的 0、1 和 2 分别对应 
stdin、stdout 和 stderr。 额外的 fd 可以被指定来创建父进程和子进程之间的额外管道。 该值是以下之一：</P>
<OL>
  <LI><CODE>'pipe'</CODE> - 创建一个子进程和父进程之间的管道。 在管道的父端以 <A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><CODE>child.stdio[fd]</CODE></A> 
  的形式作为 <CODE>child_process</CODE> 对象的一个属性暴露给父进程。 为 fd 创建的管道 0 - 2 也可分别作为 <A 
  href="http://nodejs.cn/api/child_process.html#child_process_child_stdin"><CODE>child.stdin</CODE></A>、<A 
  href="http://nodejs.cn/api/child_process.html#child_process_child_stdout"><CODE>child.stdout</CODE></A> 
  和 <A 
  href="http://nodejs.cn/api/child_process.html#child_process_child_stderr"><CODE>child.stderr</CODE></A>。</LI>
  <LI><CODE>'ipc'</CODE> - 创建一个用于父进程和子进程之间传递消息或文件描述符的 IPC 通道符。 一个 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
  最多只能有一个 IPC stdio 文件描述符。 设置该选项可启用 <A href="http://nodejs.cn/api/child_process.html#child_process_child_send_message_sendhandle_options_callback"><CODE>child.send()</CODE></A> 
  方法。 如果子进程把 JSON 消息写入到该文件描述符，则 <A href="http://nodejs.cn/api/child_process.html#child_process_event_message"><CODE>child.on('message')</CODE></A> 
  事件句柄会被父进程触发。 如果子进程是一个 Node.js 进程，则一个已存在的 IPC 通道会在子进程中启用 <A href="http://nodejs.cn/api/process.html#process_process_send_message_sendhandle_options_callback"><CODE>process.send()</CODE></A>、<A 
  href="http://nodejs.cn/api/process.html#process_process_disconnect"><CODE>process.disconnect()</CODE></A>、<A 
  href="http://nodejs.cn/api/process.html#process_event_disconnect"><CODE>process.on('disconnect')</CODE></A> 
  和 <A 
  href="http://nodejs.cn/api/process.html#process_event_message"><CODE>process.on('message')</CODE></A>。</LI>
  <LI><CODE>'ignore'</CODE> - 指示 Node.js 在子进程中忽略 fd。 由于 Node.js 总是会为它衍生的进程打开 fd 
  0 - 2，所以设置 fd 为 <CODE>'ignore'</CODE> 可以使 Node.js 打开 <CODE>/dev/null</CODE> 
  并将它附加到子进程的 fd 上。</LI>
  <LI><A class="type" 
  href="http://nodejs.cn/api/stream.html#stream_stream">&lt;Stream&gt;</A> 对象 - 
  共享一个指向子进程的 tty、文件、socket 或管道的可读或可写流。 流的底层文件描述符在子进程中是重复对应该 <CODE>stdio</CODE> 
  数组的索引的 fd。 注意，该流必须有一个底层描述符（文件流直到 <CODE>'open'</CODE> 事件发生才需要）。</LI>
  <LI>正整数 - 整数值被解析为一个正在父进程中打开的文件描述符。 它和子进程共享，类似于 <A class="type" href="http://nodejs.cn/api/stream.html#stream_stream">&lt;Stream&gt;</A> 
  是如何被共享的。</LI>
  <LI><CODE>null</CODE>, <CODE>undefined</CODE> - 使用默认值。 对于 stdio fd 0、1 和 
  2（换言之，stdin、stdout 和 stderr）而言是创建了一个管道。 对于 fd 3 及以上而言，默认值为 
  <CODE>'ignore'</CODE>。</LI></OL>
<P>例子：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;

// 子进程使用父进程的 stdios
spawn('prg', [], { stdio: 'inherit' });

// 衍生的子进程只共享 stderr
spawn('prg', [], { stdio: ['pipe', 'pipe', process.stderr] });

// 打开一个额外的 fd=4，用于与程序交互
spawn('prg', [], { stdio: ['pipe', null, null, null, 'pipe'] });
</CODE></PRE>
<P>当在父进程和子进程之间建立了一个 IPC 通道，且子进程是一个 Node.js 进程，则子进程会带着未引用的 IPC 通道（使用 
<CODE>unref()</CODE>）启动，直到子进程为 <A href="http://nodejs.cn/api/process.html#process_event_disconnect"><CODE>process.on('disconnect')</CODE></A> 
事件或 <A 
href="http://nodejs.cn/api/process.html#process_event_message"><CODE>process.on('message')</CODE></A> 
事件注册了一个事件句柄。 这使得子进程可以在进程没有通过打开的 IPC 通道保持打开的情况下正常退出。</P>
<P>详见 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A>。</P>
<H2>创建同步进程<SPAN><A class="mark" id="child_process_synchronous_process_creation" 
href="http://nodejs.cn/api/child_process.html#child_process_synchronous_process_creation">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_synchronous_process_creation">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/synchronous_process_creation.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P><A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A>、<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_execsync_command_options"><CODE>child_process.execSync()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfilesync_file_args_options"><CODE>child_process.execFileSync()</CODE></A> 
方法是<STRONG>同步的</STRONG>且<STRONG>会</STRONG>阻塞 Node.js 
的事件循环，暂停任何额外代码的执行直到衍生的进程退出。</P>
<P>像这样的阻塞调用有利于简化普通用途的脚本任务，且启动时有利于简化应用配置的加载/处理。</P>
<H3>child_process.execFileSync(file[, args][, options])<SPAN><A class="mark" id="child_process_child_process_execfilesync_file_args_options" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfilesync_file_args_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_execfilesync_file_args_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_execfilesync_file_args_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.12</SPAN> </DIV>
<UL>
  <LI><CODE>file</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的可执行文件的名称或路径</LI>
  <LI><CODE>args</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
  字符串参数列表</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>input</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
    要作为 stdin 传给衍生进程的值
    <UL>
      <LI>提供该值会覆盖 <CODE>stdio[0]</CODE></LI></UL></LI>
    <LI><CODE>stdio</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    子进程的 stdio 配置。（默认: <CODE>'pipe'</CODE>）
    <UL>
      <LI><CODE>stderr</CODE> 默认会输出到父进程中的 stderr，除非指定了 
    <CODE>stdio</CODE></LI></UL></LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    进程允许运行的最大时间数，以毫秒为单位。（默认: <CODE>undefined</CODE>）</LI>
    <LI><CODE>killSignal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    当衍生进程将被杀死时要使用的信号值。（默认: <CODE>'SIGTERM'</CODE>）</LI>
    <LI><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE></A> 
    <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止</LI>
    <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于所有 stdio 输入和输出的编码。（默认: <CODE>'buffer'</CODE>）</LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
  | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  该命令的 stdout</LI></UL>
<P><CODE>child_process.execFileSync()</CODE> 方法与 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 <CODE>killSignal</CODE> 时，则该方法直到进程完全退出后才返回结果。
 注意，如果子进程拦截并处理了 <CODE>SIGTERM</CODE> 信号且没有退出，则父进程会一直等待直到子进程退出。</P>
<P>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A> 
对象会包含从 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A> 
返回的整个结果。</P>
<H3>child_process.execSync(command[, options])<SPAN><A class="mark" id="child_process_child_process_execsync_command_options" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_execsync_command_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_execsync_command_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_execsync_command_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.12</SPAN> </DIV>
<UL>
  <LI><CODE>command</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的命令</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>input</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
    要作为 stdin 传给衍生进程的值
    <UL>
      <LI>提供该值会覆盖 <CODE>stdio[0]</CODE></LI></UL></LI>
    <LI><CODE>stdio</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    子进程的 stdio 配置。（默认: <CODE>'pipe'</CODE>）
    <UL>
      <LI><CODE>stderr</CODE> 默认会输出到父进程中的 stderr，除非指定了 
    <CODE>stdio</CODE></LI></UL></LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>shell</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于执行命令的 shell （默认：在 UNIX 上为 <CODE>'/bin/sh'</CODE>，在 Windows 上为 
    <CODE>'cmd.exe'</CODE>。 该 shell 应该能够理解 UNIX 的 <CODE>-c</CODE> 开关或 Windows 的 
    <CODE>/s /c</CODE> 开关。 在 Windows 中，命令行的解析应与 <CODE>cmd.exe</CODE> 兼容。）</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    进程允许运行的最大时间数，以毫秒为单位。（默认: <CODE>undefined</CODE>）</LI>
    <LI><CODE>killSignal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    当衍生进程将被杀死时要使用的信号值。（默认: <CODE>'SIGTERM'</CODE>）</LI>
    <LI><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE></A> 
    <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止</LI>
    <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于所有 stdio 输入和输出的编码。（默认: <CODE>'buffer'</CODE>）</LI></UL></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
  | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  该命令的 stdout</LI></UL>
<P><CODE>child_process.execSync()</CODE> 方法与 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A> 
基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 <CODE>killSignal</CODE> 时，则该方法直到进程完全退出后才返回结果。
 注意，如果子进程拦截并处理了 <CODE>SIGTERM</CODE> 信号且没有退出，则父进程会一直等待直到子进程退出。</P>
<P>如果进程超时，或有一个非零的退出码，则该方法会抛出错误。 <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A> 
对象会包含从 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options"><CODE>child_process.spawnSync()</CODE></A> 
返回的整个结果。</P>
<P>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</P>
<H3>child_process.spawnSync(command[, args][, options])<SPAN><A class="mark" id="child_process_child_process_spawnsync_command_args_options" 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawnsync_command_args_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_process_spawnsync_command_args_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_process_spawnsync_command_args_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.12</SPAN> </DIV>
<UL>
  <LI><CODE>command</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  要运行的命令</LI>
  <LI><CODE>args</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
  字符串参数列表</LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>cwd</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    子进程的当前工作目录</LI>
    <LI><CODE>input</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
    要作为 stdin 传给衍生进程的值
    <UL>
      <LI>提供该值会覆盖 <CODE>stdio[0]</CODE></LI></UL></LI>
    <LI><CODE>stdio</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    子进程的 stdio 配置</LI>
    <LI><CODE>env</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    环境变量键值对</LI>
    <LI><CODE>uid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的用户标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setuid.2.html">setuid(2)</A>）</LI>
    <LI><CODE>gid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    设置该进程的组标识。（详见 <A 
    href="http://man7.org/linux/man-pages/man2/setgid.2.html">setgid(2)</A>）</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    进程允许运行的最大时间数，以毫秒为单位。（默认: <CODE>undefined</CODE>）</LI>
    <LI><CODE>killSignal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    当衍生进程将被杀死时要使用的信号值。（默认: <CODE>'SIGTERM'</CODE>）</LI>
    <LI><A href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode"><CODE>maxBuffer</CODE></A> 
    <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    stdout 或 stderr 允许的最大数据量（以字节为单位）。 如果超过限制，则子进程会被终止</LI>
    <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于所有 stdio 输入和输出的编码。（默认: <CODE>'buffer'</CODE>）</LI>
    <LI><CODE>shell</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    如果为 <CODE>true</CODE>，则在一个 shell 中运行 <CODE>command</CODE>。 在 UNIX 上使用 
    <CODE>'/bin/sh'</CODE>，在 Windows 上使用 <CODE>'cmd.exe'</CODE>。 一个不同的 shell 
    可以被指定为字符串。 该 shell 应该理解 UNIX 上的 <CODE>-c</CODE> 开关、或 Windows 的 <CODE>/s 
    /c</CODE>。 默认为 <CODE>false</CODE>（没有 shell）。</LI></UL></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>pid</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    子进程的 pid</LI>
    <LI><CODE>output</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A> 
    stdio 输出返回的结果数组</LI>
    <LI><CODE>stdout</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    <CODE>output[1]</CODE> 的内容 </LI>
    <LI><CODE>stderr</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    <CODE>output[2]</CODE> 的内容</LI>
    <LI><CODE>status</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    子进程的退出码</LI>
    <LI><CODE>signal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    用于杀死子进程的信号</LI>
    <LI><CODE>error</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A> 
    如果子进程失败或超时产生的错误对象</LI></UL></LI></UL>
<P><CODE>child_process.spawnSync()</CODE> 方法与 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
基本相同，除了该方法直到子进程完全关闭后才返回。 当遇到超时且发送了 <CODE>killSignal</CODE> 时，则该方法直到进程完全退出后才返回结果。
 注意，如果子进程拦截并处理了 <CODE>SIGTERM</CODE> 信号且没有退出，则父进程会一直等待直到子进程退出。</P>
<P>注意：不要把未经检查的用户输入传入到该函数。 任何包括 shell 元字符的输入都可被用于触发任何命令的执行。</P>
<H2>ChildProcess 类<SPAN><A class="mark" id="child_process_class_childprocess" 
href="http://nodejs.cn/api/child_process.html#child_process_class_childprocess">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_class_childprocess">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/class_childprocess.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v2.2.0</SPAN> </DIV>
<P><CODE>ChildProcess</CODE> 类的实例是 <A href="http://nodejs.cn/api/events.html#events_class_eventemitter"><CODE>EventEmitter</CODE></A>，代表衍生的子进程。</P>
<P><CODE>ChildProcess</CODE> 的实例不被直接创建。 而是，使用 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A>、<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_exec_command_options_callback"><CODE>child_process.exec()</CODE></A>、<A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><CODE>child_process.execFile()</CODE></A> 
或 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A> 
方法创建 <CODE>ChildProcess</CODE> 实例。</P>
<H3>'close' 事件<SPAN><A class="mark" id="child_process_event_close" href="http://nodejs.cn/api/child_process.html#child_process_event_close">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_event_close">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/event_close.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>code</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
  如果子进程退出自身，则该值是退出码。</LI>
  <LI><CODE>signal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  子进程被终止时的信号。</LI></UL>
<P>当子进程的 stdio 流被关闭时会触发 <CODE>'close'</CODE> 事件。 这与 <A href="http://nodejs.cn/api/child_process.html#child_process_event_exit"><CODE>'exit'</CODE></A> 
事件不同，因为多个进程可能共享同一 stdio 流。</P>
<H3>'disconnect' 事件<SPAN><A class="mark" id="child_process_event_disconnect" 
href="http://nodejs.cn/api/child_process.html#child_process_event_disconnect">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_event_disconnect">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/event_disconnect.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.2</SPAN> </DIV>
<P>在父进程中调用 <A href="http://nodejs.cn/api/child_process.html#child_process_child_disconnect"><CODE>child.disconnect()</CODE></A> 
或在子进程中调用 <A 
href="http://nodejs.cn/api/process.html#process_process_disconnect"><CODE>process.disconnect()</CODE></A> 
后会触发 <CODE>'disconnect'</CODE> 事件。 断开后就不能再发送或接收信息，且 <A href="http://nodejs.cn/api/child_process.html#child_process_child_connected"><CODE>child.connected</CODE></A> 
属性会被设为 <CODE>false</CODE>。</P>
<H3>'error' 事件<SPAN><A class="mark" id="child_process_event_error" href="http://nodejs.cn/api/child_process.html#child_process_event_error">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_event_error">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/event_error.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>err</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A> 
  错误对象。</LI></UL></DIV>
<P>每当出现以下情况时触发 <CODE>'error'</CODE> 事件：</P>
<OL>
  <LI>
  <P>进程无法被衍生；</P></LI>
  <LI>
  <P>进程无法被杀死；</P></LI>
  <LI>
  <P>向子进程发送信息失败。</P></LI></OL>
<P>注意，在错误发生后，<CODE>'exit'</CODE> 事件可能会也可能不会触发。 如果你同时监听了 <CODE>'exit'</CODE> 和 
<CODE>'error'</CODE> 事件，谨防处理函数被多次调用。</P>
<P>详见 <A href="http://nodejs.cn/api/child_process.html#child_process_child_kill_signal"><CODE>child.kill()</CODE></A> 
和 <A href="http://nodejs.cn/api/child_process.html#child_process_child_send_message_sendhandle_options_callback"><CODE>child.send()</CODE></A>。</P>
<H3>'exit' 事件<SPAN><A class="mark" id="child_process_event_exit" href="http://nodejs.cn/api/child_process.html#child_process_event_exit">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_event_exit">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/event_exit.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>code</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
  如果子进程退出自身，则该值是退出码。</LI>
  <LI><CODE>signal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  子进程被终止时的信号。</LI></UL>
<P>子进程结束后会触发 <CODE>'exit'</CODE> 事件。 如果进程退出了，则 <CODE>code</CODE> 是进程的最终退出码，否则为 
<CODE>null</CODE>。 如果进程是收到的信号而终止的，则 <CODE>signal</CODE> 是信号的字符串名称，否则为 
<CODE>null</CODE>。 这两个总有一个是非空的。</P>
<P>注意，当 <CODE>'exit'</CODE> 事件被触发时，子进程的 stdio 流可能依然是打开的。</P>
<P>另外，还要注意，Node.js 建立了 <CODE>SIGINT</CODE> 和 <CODE>SIGTERM</CODE> 的信号处理程序，且 
Node.js 进程收到这些信号也不会立即终止。 相反，Node.js 会执行一系列的清理操作后重新引发处理信号。</P>
<P>详见 <A 
href="http://man7.org/linux/man-pages/man2/waitpid.2.html">waitpid(2)</A>。</P>
<H3>'message' 事件<SPAN><A class="mark" id="child_process_event_message" href="http://nodejs.cn/api/child_process.html#child_process_event_message">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_event_message">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/event_message.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>message</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  一个已解析的 JSON 对象或原始值。</LI>
  <LI><CODE>sendHandle</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_server_listen_handle_backlog_callback">&lt;Handle&gt;</A> 
  一个 <A 
  href="http://nodejs.cn/api/net.html#net_class_net_socket"><CODE>net.Socket</CODE></A> 
  或 <A 
  href="http://nodejs.cn/api/net.html#net_class_net_server"><CODE>net.Server</CODE></A> 
  对象 或 <CODE>undefined</CODE>。</LI></UL>
<P>当一个子进程使用 <A href="http://nodejs.cn/api/process.html#process_process_send_message_sendhandle_options_callback"><CODE>process.send()</CODE></A> 
发送消息时会触发 <CODE>'message'</CODE> 事件。</P>
<H3>child.connected<SPAN><A class="mark" id="child_process_child_connected" 
href="http://nodejs.cn/api/child_process.html#child_process_child_connected">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_connected">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_connected.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.2</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
  调用 <CODE>child.disconnect()</CODE> 后会被设为 <CODE>false</CODE></LI></UL>
<P><CODE>child.connected</CODE> 属性表明是否仍可以从一个子进程发送和接收消息。 当 
<CODE>child.connected</CODE> 为 <CODE>false</CODE> 时，则不能再发送或接收的消息。</P>
<H3>child.disconnect()<SPAN><A class="mark" id="child_process_child_disconnect" 
href="http://nodejs.cn/api/child_process.html#child_process_child_disconnect">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_disconnect">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_disconnect.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.2</SPAN> </DIV>
<P>关闭父进程与子进程之间的 IPC 通道，一旦没有其他的连接使其保持活跃，则允许子进程正常退出。 调用该方法后，父进程和子进程上各自的 
<CODE>child.connected</CODE> 和 <CODE>process.connected</CODE> 属性都会被设为 
<CODE>false</CODE>，且进程之间不能再传递消息。</P>
<P>当正在接收的进程中没有消息时，就会触发 <CODE>'disconnect'</CODE> 事件。 这经常在调用 
<CODE>child.disconnect()</CODE> 后立即被触发。</P>
<P>注意，当子进程是一个 Node.js 实例时（例如通过 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A> 
衍生的），可以在子进程内调用 <CODE>process.disconnect()</CODE> 方法来关闭 IPC 通道。</P>
<H3>child.kill([signal])<SPAN><A class="mark" id="child_process_child_kill_signal" 
href="http://nodejs.cn/api/child_process.html#child_process_child_kill_signal">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_kill_signal">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_kill_signal.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>signal</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P><CODE>child.kill()</CODE> 方法向子进程发送一个信号。 如果没有给定参数，则进程会发送 
<CODE>'SIGTERM'</CODE> 信号。 查看 <A href="http://man7.org/linux/man-pages/man7/signal.7.html">signal(7)</A> 
了解可用的信号列表。</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const grep = spawn('grep', ['ssh']);

grep.on('close', (code, signal) =&gt; {
  console.log(`子进程收到信号 ${signal} 而终止`);
});

// 发送 SIGHUP 到进程
grep.kill('SIGHUP');
</CODE></PRE>
<P>如果信号没有被送达，<A href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
对象可能会触发一个 <A href="http://nodejs.cn/api/child_process.html#child_process_event_error"><CODE>'error'</CODE></A> 
事件。 向一个已经退出的子进程发送信号不是一个错误，但可能有无法预知的后果。 特别是，如果进程的 PID 
已经重新分配给其他进程，则信号会被发送到该进程，从而可能有意想不到的结果。</P>
<P>注意，当函数被调用 <CODE>kill</CODE> 时，已发送到子进程的信号可能没有实际终止该进程。</P>
<P>详见 <A 
href="http://man7.org/linux/man-pages/man2/kill.2.html">kill(2)</A>。</P>
<P>注意：在 Linux 上，当试图杀死父进程时，子进程的子进程不会被终止。 这有可能发生在当在一个 shell 中运行一个新进程时，或使用 
<CODE>ChildProcess</CODE> 中的 <CODE>shell</CODE> 选项时，例如：</P>
<PRE><CODE class="lang-js">'use strict';
const spawn = require('child_process').spawn;

const child = spawn('sh', ['-c',
  `node -e "setInterval(() =&gt; {
      console.log(process.pid, 'is alive')
    }, 500);"`
  ], {
    stdio: ['inherit', 'inherit', 'inherit']
  });

setTimeout(() =&gt; {
  child.kill(); // 不会终止 shell 中的 node 进程
}, 2000);
</CODE></PRE>
<H3>child.pid<SPAN><A class="mark" id="child_process_child_pid" href="http://nodejs.cn/api/child_process.html#child_process_child_pid">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_pid">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_pid.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
  整数</LI></UL>
<P>返回子进程的进程标识（PID）。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">const spawn = require('child_process').spawn;
const grep = spawn('grep', ['ssh']);

console.log(`衍生的子进程的 pid：${grep.pid}`);
grep.stdin.end();
</CODE></PRE>
<H3>child.send(message[, sendHandle[, options]][, callback])<SPAN><A class="mark" 
id="child_process_child_send_message_sendhandle_options_callback" href="http://nodejs.cn/api/child_process.html#child_process_child_send_message_sendhandle_options_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_send_message_sendhandle_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_send_message_sendhandle_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>message</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI>
  <LI><CODE>sendHandle</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_server_listen_handle_backlog_callback">&lt;Handle&gt;</A></LI>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>当父进程和子进程之间建立了一个 IPC 通道时（例如，使用 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_fork_modulepath_args_options"><CODE>child_process.fork()</CODE></A>），<CODE>child.send()</CODE> 
方法可用于发送消息到子进程。 当子进程是一个 Node.js 实例时，消息可以通过 <A href="http://nodejs.cn/api/process.html#process_event_message"><CODE>process.on('message')</CODE></A> 
事件接收。</P>
<P>例子，父进程脚本如下：</P>
<PRE><CODE class="lang-js">const cp = require('child_process');
const n = cp.fork(`${__dirname}/sub.js`);

n.on('message', (m) =&gt; {
  console.log('父进程收到消息：', m);
});

n.send({ hello: 'world' });
</CODE></PRE>
<P>然后是子进程脚本，<CODE>'sub.js'</CODE> 可能看上去像这样：</P>
<PRE><CODE class="lang-js">process.on('message', (m) =&gt; {
  console.log('子进程收到消息：', m);
});

process.send({ foo: 'bar' });
</CODE></PRE>
<P>Node.js 中的子进程有一个自己的 <A href="http://nodejs.cn/api/process.html#process_process_send_message_sendhandle_options_callback"><CODE>process.send()</CODE></A> 
方法，允许子进程发送消息回父进程。</P>
<P>当发送一个 <CODE>{cmd: 'NODE_foo'}</CODE> 消息时，是一个特例。 所有在 <CODE>cmd</CODE> 属性里包含一个 
<CODE>NODE_</CODE> 前缀的都会被认为是预留给 Node.js 核心代码内部使用的，且不会触发子进程的 <A href="http://nodejs.cn/api/process.html#process_event_message"><CODE>process.on('message')</CODE></A> 
事件。 而是，这种消息可使用 <CODE>process.on('internalMessage')</CODE> 事件触发，且被 Node.js 内部消费。
 应用程序应避免使用这种消息或监听 <CODE>'internalMessage'</CODE> 事件。</P>
<P>可选的 <CODE>sendHandle</CODE> 参数可能被传给 <CODE>child.send()</CODE>，它用于传入一个 TCP 
服务器或 socket 对象给子进程。 子进程会接收对象作为第二个参数，并传给注册在 <A href="http://nodejs.cn/api/process.html#process_event_message"><CODE>process.on('message')</CODE></A> 
事件上的回调函数。 socket 上接收或缓冲的任何数据不会被发送给子进程。</P>
<P><CODE>options</CODE> 参数，如果存在的话，是一个用于处理发送数据参数对象。<CODE>options</CODE> 
支持以下属性：</P>
<UL>
  <LI><CODE>keepOpen</CODE> - 一个 Boolean 值，当传入 <CODE>net.Socket</CODE> 实例时可用。 当为 
  <CODE>true</CODE> 时，socket 在发送进程中保持打开。 默认为 <CODE>false</CODE>。</LI></UL>
<P>可选的 <CODE>callback</CODE> 是一个函数，它在消息发送之后、子进程收到消息之前被调用。 该函数被调用时只有一个参数：成功时是 
<CODE>null</CODE>，失败时是一个 <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A> 
对象。</P>
<P>如果没有提供 <CODE>callback</CODE> 函数，且消息没被发送，则一个 <CODE>'error'</CODE> 事件将被 <A 
href="http://nodejs.cn/api/child_process.html#child_process_child_process"><CODE>ChildProcess</CODE></A> 
对象触发。 这是有可能发生的，例如当子进程已经退出时。</P>
<P>如果通道已关闭，或当未发送的消息的积压超过阈值使其无法发送更多时，<CODE>child.send()</CODE> 会返回 
<CODE>false</CODE>。 除此以外，该方法返回 <CODE>true</CODE>。 <CODE>callback</CODE> 
函数可用于实现流量控制。</P>
<H4>例子：发送一个 server 对象<SPAN><A class="mark" id="child_process_example_sending_a_server_object" 
href="http://nodejs.cn/api/child_process.html#child_process_example_sending_a_server_object">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_example_sending_a_server_object">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/example_sending_a_server_object.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P><CODE>sendHandle</CODE> 参数可用于将一个 TCP server 对象句柄传给子进程，如下所示：</P>
<PRE><CODE class="lang-js">const child = require('child_process').fork('child.js');

// 开启 server 对象，并发送该句柄。
const server = require('net').createServer();
server.on('connection', (socket) =&gt; {
  socket.end('被父进程处理');
});
server.listen(1337, () =&gt; {
  child.send('server', server);
});
</CODE></PRE>
<P>子进程接收 server 对象如下：</P>
<PRE><CODE class="lang-js">process.on('message', (m, server) =&gt; {
  if (m === 'server') {
    server.on('connection', (socket) =&gt; {
      socket.end('被子进程处理');
    });
  }
});
</CODE></PRE>
<P>当服务器在父进程和子进程之间是共享的，则一些连接可被父进程处理，另一些可被子进程处理。</P>
<P>上面的例子使用了一个 <CODE>net</CODE> 模块创建的服务器，而 <CODE>dgram</CODE> 
模块的服务器使用完全相同的工作流程，但它监听一个 <CODE>'message'</CODE> 事件而不是 <CODE>'connection'</CODE> 
事件，且使用 <CODE>server.bind</CODE> 而不是 <CODE>server.listen()</CODE>。 目前仅 UNIX 
平台支持这一点。</P>
<H4>例子：发送一个 socket 对象<SPAN><A class="mark" id="child_process_example_sending_a_socket_object" 
href="http://nodejs.cn/api/child_process.html#child_process_example_sending_a_socket_object">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_example_sending_a_socket_object">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/example_sending_a_socket_object.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>同样，<CODE>sendHandle</CODE> 参数可用于将一个 socket 句柄传给子进程。 以下例子衍生了两个子进程，分别用于处理 
"normal" 连接或优先处理 "special" 连接：</P>
<PRE><CODE class="lang-js">const normal = require('child_process').fork('child.js', ['normal']);
const special = require('child_process').fork('child.js', ['special']);

// 开启 server，并发送 socket 给子进程
const server = require('net').createServer();
server.on('connection', (socket) =&gt; {

  // 特殊优先级
  if (socket.remoteAddress === '74.125.127.100') {
    special.send('socket', socket);
    return;
  }
  // 普通优先级
  normal.send('socket', socket);
});
server.listen(1337);
</CODE></PRE>
<P><CODE>child.js</CODE> 会接收到一个 socket 句柄，并作为第二个参数传给事件回调函数：</P>
<PRE><CODE class="lang-js">process.on('message', (m, socket) =&gt; {
  if (m === 'socket') {
    socket.end(`请求被 ${process.argv[2]} 优先级处理`);
  }
});
</CODE></PRE>
<P>一旦一个 socket 已被传给了子进程，则父进程不再能够跟踪 socket 何时被销毁。
 为了表明这个，<CODE>.connections</CODE> 属性会变成 <CODE>null</CODE>。 当发生这种情况时，建议不要使用 
<CODE>.maxConnections</CODE>。</P>
<P>注意，该函数内部使用 <A href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><CODE>JSON.stringify()</CODE></A> 
序列化 <CODE>message</CODE>。</P>
<H3>child.stderr<SPAN><A class="mark" id="child_process_child_stderr" href="http://nodejs.cn/api/child_process.html#child_process_child_stderr">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_stderr">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_stderr.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><A class="type" href="http://nodejs.cn/api/stream.html#stream_class_stream_readable">&lt;stream.Readable&gt;</A></LI></UL>
<P>一个代表子进程的 <CODE>stderr</CODE> 的可读流。</P>
<P>如果子进程被衍生时 <CODE>stdio[2]</CODE> 被设为任何不是 <CODE>'pipe'</CODE> 的值，则这会是 
<CODE>null</CODE>。</P>
<P><CODE>child.stderr</CODE> 是 <CODE>child.stdio[2]</CODE> 的一个别名。
 这两个属性指向相同的值。</P>
<H3>child.stdin<SPAN><A class="mark" id="child_process_child_stdin" href="http://nodejs.cn/api/child_process.html#child_process_child_stdin">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_stdin">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_stdin.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><A class="type" href="http://nodejs.cn/api/stream.html#stream_class_stream_writable">&lt;stream.Writable&gt;</A></LI></UL>
<P>一个代表子进程的 <CODE>stdin</CODE> 的可写流。</P>
<P>注意，如果一个子进程正在等待读取所有的输入，则子进程不会继续直到流已通过 <CODE>end()</CODE> 关闭。</P>
<P>如果子进程被衍生时 <CODE>stdio[0]</CODE> 被设为任何不是 <CODE>'pipe'</CODE> 的值，则这会是 
<CODE>null</CODE>。</P>
<P><CODE>child.stdin</CODE> 是 <CODE>child.stdio[0]</CODE> 的一个别名。
 这两个属性指向相同的值。</P>
<H3>child.stdio<SPAN><A class="mark" id="child_process_child_stdio" href="http://nodejs.cn/api/child_process.html#child_process_child_stdio">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_stdio">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_stdio.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.10</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL>
<P>一个到子进程的管道的稀疏数组，对应着传给 <A href="http://nodejs.cn/api/child_process.html#child_process_child_process_spawn_command_args_options"><CODE>child_process.spawn()</CODE></A> 
的选项中值被设为 <CODE>'pipe'</CODE> 的 <A href="http://nodejs.cn/api/child_process.html#child_process_options_stdio"><CODE>stdio</CODE></A>。
 注意，<CODE>child.stdio[0]</CODE>、<CODE>child.stdio[1]</CODE> 和 
<CODE>child.stdio[2]</CODE> 分别可用作 <CODE>child.stdin</CODE>、 
<CODE>child.stdout</CODE> 和 <CODE>child.stderr</CODE>。</P>
<P>在下面的例子中，只有子进程的 fd <CODE>1</CODE>（stdout）被配置为一个管道，所以只有父进程的 
<CODE>child.stdio[1]</CODE> 是一个流，数组中的其他值都是 <CODE>null</CODE>。</P>
<PRE><CODE class="lang-js">const assert = require('assert');
const fs = require('fs');
const child_process = require('child_process');

const child = child_process.spawn('ls', {
  stdio: [
    0, // 使用父进程的 stdin 用于子进程
    'pipe', // 把子进程的 stdout 通过管道传到父进程 
    fs.openSync('err.out', 'w') // 把子进程的 stderr 指向一个文件
  ]
});

assert.strictEqual(child.stdio[0], null);
assert.strictEqual(child.stdio[0], child.stdin);

assert(child.stdout);
assert.strictEqual(child.stdio[1], child.stdout);

assert.strictEqual(child.stdio[2], null);
assert.strictEqual(child.stdio[2], child.stderr);
</CODE></PRE>
<H3>child.stdout<SPAN><A class="mark" id="child_process_child_stdout" href="http://nodejs.cn/api/child_process.html#child_process_child_stdout">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_child_stdout">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/child_stdout.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><A class="type" href="http://nodejs.cn/api/stream.html#stream_class_stream_readable">&lt;stream.Readable&gt;</A></LI></UL>
<P>一个代表子进程的 <CODE>stdout</CODE> 的可读流。</P>
<P>如果子进程被衍生时 <CODE>stdio[1]</CODE> 被设为任何不是 <CODE>'pipe'</CODE> 的值，则这会是 
<CODE>null</CODE>。</P>
<P><CODE>child.stdout</CODE> 是 <CODE>child.stdio[1]</CODE> 的一个别名。
 这两个属性指向相同的值。</P>
<H2><CODE>maxBuffer</CODE> 与 Unicode<SPAN><A class="mark" id="child_process_maxbuffer_and_unicode" 
href="http://nodejs.cn/api/child_process.html#child_process_maxbuffer_and_unicode">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/child_process.html#child_process_maxbuffer_and_unicode">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/child_process/maxbuffer_and_unicode.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P><CODE>maxBuffer</CODE> 选项指定了 <CODE>stdout</CODE> 或 <CODE>stderr</CODE> 
上允许的字节数的最大值。 如果超过这个值，则子进程会被终止。 这会影响包含多字节字符编码的输出，如 UTF-8 或 UTF-16。
 例如，<CODE>console.log('中文测试')</CODE> 会发送 13 个 UTF-8 编码的字节到 
<CODE>stdout</CODE>，尽管只有 4 个字符。</P></DIV></DIV></DIV><!-- 搜索弹窗 -->   
<DIV id="modal_search_bg"></DIV>
<DIV 
id="modal_search"><INPUT id="modal_search_input" placeholder="API 快速搜索" value=""> 
    
<DIV id="modal_search_result"></DIV></DIV><!-- js -->   <!--[if lt IE 10]><script src="/static/lib/placeholders.js?20170426"></script><![endif]--> 
  
<SCRIPT src="child_process%20%20Node_js%20API%20文档_files/api.js"></SCRIPT>
 </BODY></HTML>
