<!DOCTYPE HTML>
<!-- saved from url=(0032)http://nodejs.cn/api/domain.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cmn-Hans"><HEAD><META 
content="IE=11.0000" http-equiv="X-UA-Compatible">
   
<META charset="utf-8">   <TITLE>domain | Node.js API 文档</TITLE>   <LINK href="domain%20%20Node_js%20API%20文档_files/api.css" 
rel="stylesheet">   <LINK href="/static/favicon.png" rel="icon" type="image/png" 
sizes="32x32"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18639"></HEAD> 
<BODY class="alt apidoc" id="api-section-domain">
<DIV class="clearfix" id="content">
<DIV class="interior" id="column2">
<DIV class="interior" id="intro"><A href="http://nodejs.cn/">          Node.js 
中文网         </A>         
<DIV><INPUT id="search_input" placeholder="API 快速搜索" value="">         
</DIV></DIV>
<UL>
  <LI><A class="nav-documentation" href="http://nodejs.cn/api/documentation.html">关于本文档</A></LI>
  <LI><A class="nav-synopsis" 
  href="http://nodejs.cn/api/synopsis.html">用法与例子</A></LI></UL>
<DIV class="line"></DIV>
<UL>
  <LI><A class="nav-assert" href="http://nodejs.cn/api/assert.html">Assert 
  (断言)</A></LI>
  <LI><A class="nav-buffer" 
  href="http://nodejs.cn/api/buffer.html">Buffer</A></LI>
  <LI><A class="nav-addons" href="http://nodejs.cn/api/addons.html">C/C++ 
  插件</A></LI>
  <LI><A class="nav-child_process" href="http://nodejs.cn/api/child_process.html">Child 
  Processes (子进程)</A></LI>
  <LI><A class="nav-cluster" href="http://nodejs.cn/api/cluster.html">Cluster 
  (集群)</A></LI>
  <LI><A class="nav-cli" href="http://nodejs.cn/api/cli.html">CLI 
  (命令行选项)</A></LI>
  <LI><A class="nav-console" href="http://nodejs.cn/api/console.html">Console 
  (控制台)</A></LI>
  <LI><A class="nav-crypto" href="http://nodejs.cn/api/crypto.html">Crypto 
  (加密)</A></LI>
  <LI><A class="nav-debugger" href="http://nodejs.cn/api/debugger.html">Debugger 
  (调试器)</A></LI>
  <LI><A class="nav-dns" href="http://nodejs.cn/api/dns.html">DNS 
  (域名服务器)</A></LI>
  <LI><A class="nav-domain active" 
  href="http://nodejs.cn/api/domain.html">Domain (域)</A></LI>
  <LI><A class="nav-errors" href="http://nodejs.cn/api/errors.html">Error 
  (错误)</A></LI>
  <LI><A class="nav-events" href="http://nodejs.cn/api/events.html">Events 
  (事件)</A></LI>
  <LI><A class="nav-fs" href="http://nodejs.cn/api/fs.html">File System 
  (文件系统)</A></LI>
  <LI><A class="nav-globals" href="http://nodejs.cn/api/globals.html">Global 
  (全局变量)</A></LI>
  <LI><A class="nav-http" href="http://nodejs.cn/api/http.html">HTTP</A></LI>
  <LI><A class="nav-https" href="http://nodejs.cn/api/https.html">HTTPS</A></LI>
  <LI><A class="nav-modules" href="http://nodejs.cn/api/modules.html">Module 
  (模块)</A></LI>
  <LI><A class="nav-net" href="http://nodejs.cn/api/net.html">Net (网络)</A></LI>
  <LI><A class="nav-os" href="http://nodejs.cn/api/os.html">OS (操作系统)</A></LI>
  <LI><A class="nav-path" href="http://nodejs.cn/api/path.html">Path 
  (路径)</A></LI>
  <LI><A class="nav-process" href="http://nodejs.cn/api/process.html">Process 
  (进程)</A></LI>
  <LI><A class="nav-punycode" 
  href="http://nodejs.cn/api/punycode.html">Punycode</A></LI>
  <LI><A class="nav-querystring" 
  href="http://nodejs.cn/api/querystring.html">Query Strings (查询字符串)</A></LI>
  <LI><A class="nav-readline" href="http://nodejs.cn/api/readline.html">Readline 
  (逐行读取)</A></LI>
  <LI><A class="nav-repl" href="http://nodejs.cn/api/repl.html">REPL 
  (交互式解释器)</A></LI>
  <LI><A class="nav-stream" href="http://nodejs.cn/api/stream.html">Stream 
  (流)</A></LI>
  <LI><A class="nav-string_decoder" href="http://nodejs.cn/api/string_decoder.html">String 
  Decoder (字符串解码器)</A></LI>
  <LI><A class="nav-timers" href="http://nodejs.cn/api/timers.html">Timer 
  (定时器)</A></LI>
  <LI><A class="nav-tls" href="http://nodejs.cn/api/tls.html">TLS 
  (安全传输层)</A></LI>
  <LI><A class="nav-tty" href="http://nodejs.cn/api/tty.html">TTY (终端)</A></LI>
  <LI><A class="nav-dgram" href="http://nodejs.cn/api/dgram.html">UDP/Datagram 
  (数据报)</A></LI>
  <LI><A class="nav-url" href="http://nodejs.cn/api/url.html">URL</A></LI>
  <LI><A class="nav-util" href="http://nodejs.cn/api/util.html">Util 
  (实用工具)</A></LI>
  <LI><A class="nav-v8" href="http://nodejs.cn/api/v8.html">V8</A></LI>
  <LI><A class="nav-vm" href="http://nodejs.cn/api/vm.html">VM (虚拟机)</A></LI>
  <LI><A class="nav-zlib" href="http://nodejs.cn/api/zlib.html">ZLIB 
  (压缩)</A></LI></UL>
<DIV class="line"></DIV></DIV>
<DIV class="interior" id="column1" data-id="domain"><HEADER>
<H1>Node.js v6.10.3 文档</H1>
<DIV id="gtoc">
<P><A name="toc" href="http://nodejs.cn/api/">返回文档首页</A>             <!--<a href="/api/all.html">单页面显示</a> |--> 
            <!--<a href="/api/domain.json">JSON格式</a> |-->             <!--<a href="/api/en/domain.html">查看英文版</a>--> 
          </P></DIV>
<HR>
</HEADER>
<DIV id="toc">
<H2>目录</H2>
<UL>
  <LI><SPAN class="stability_0"><A href="http://nodejs.cn/api/domain.html#domain_domain">domain 
  (域)</A></SPAN>
  <UL> 
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_warning_don_t_ignore_errors">Warning: 
    Don't Ignore Errors!</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_additions_to_error_objects">Additions 
    to Error objects</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_implicit_binding">Implicit 
    Binding</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_explicit_binding">Explicit 
    Binding</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_create">domain.create()</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_class_domain">Class: 
    Domain</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_run_fn_args">domain.run(fn[, 
      ...args])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_members">domain.members</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_add_emitter">domain.add(emitter)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_remove_emitter">domain.remove(emitter)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_bind_callback">domain.bind(callback)</A></SPAN>
      <UL> 
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_example">Example</A></SPAN></LI></UL></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_intercept_callback">domain.intercept(callback)</A></SPAN>
      <UL> 
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_example_1">Example</A></SPAN></LI></UL></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_enter">domain.enter()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/domain.html#domain_domain_exit">domain.exit()</A></SPAN></LI>
      <LI><SPAN class="stability_0"><A href="http://nodejs.cn/api/domain.html#domain_domain_dispose">domain.dispose()</A></SPAN></LI></UL></LI></UL></LI></UL></DIV>
<DIV id="apicontent">
<H1>domain (域)<SPAN><A class="mark" id="domain_domain" href="http://nodejs.cn/api/domain.html#domain_domain">#</A></SPAN></H1>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_0"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 0</A> - 废弃的</PRE>
<P><STRONG>该模块即将废弃</STRONG>。Once a replacement API has been finalized, this 
module will be fully deprecated. Most end users should <STRONG>not</STRONG> have 
cause to use this module. Users who absolutely must have the functionality that 
domains provide may rely on it for the time being but should expect to have to 
migrate to a different solution in the future.</P>
<P>Domains provide a way to handle multiple different IO operations as a single 
group.  If any of the event emitters or callbacks registered to a domain emit an 
<CODE>'error'</CODE> event, or throw an error, then the domain object will be 
notified, rather than losing the context of the error in the 
<CODE>process.on('uncaughtException')</CODE> handler, or causing the program to
 exit immediately with an error code.</P>
<H2>Warning: Don't Ignore Errors!<SPAN><A class="mark" id="domain_warning_don_t_ignore_errors" 
href="http://nodejs.cn/api/domain.html#domain_warning_don_t_ignore_errors">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_warning_don_t_ignore_errors">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/warning_don_t_ignore_errors.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>Domain error handlers are not a substitute for closing down your process when 
an error occurs.</P>
<P>By the very nature of how <A href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/throw"><CODE>throw</CODE></A> 
works in JavaScript, there is almost never any way to safely "pick up where you 
left off", without leaking references, or creating some other sort of undefined 
brittle state.</P>
<P>The safest way to respond to a thrown error is to shut down the process.  Of 
course, in a normal web server, you might have many connections open, and it is 
not reasonable to abruptly shut those down because an error was triggered by 
someone else.</P>
<P>The better approach is to send an error response to the request that
 triggered the error, while letting the others finish in their normal time, and 
stop listening for new requests in that worker.</P>
<P>In this way, <CODE>domain</CODE> usage goes hand-in-hand with the cluster 
module, since the master process can fork a new worker when a worker encounters 
an error.  For Node.js programs that scale to multiple machines, the terminating 
proxy or service registry can take note of the failure, and react 
accordingly.</P>
<P>For example, this is not a good idea:</P>
<PRE><CODE class="lang-js">// XXX WARNING!  BAD IDEA!

const d = require('domain').create();
d.on('error', (er) =&gt; {
  // The error won't crash the process, but what it does is worse!
  // Though we've prevented abrupt process restarting, we are leaking
  // resources like crazy if this ever happens.
  // This is no better than process.on('uncaughtException')!
  console.log(`error, but oh well ${er.message}`);
});
d.run(() =&gt; {
  require('http').createServer((req, res) =&gt; {
    handleRequest(req, res);
  }).listen(PORT);
});
</CODE></PRE>
<P>By using the context of a domain, and the resilience of separating our
 program into multiple worker processes, we can react more appropriately, and 
handle errors with much greater safety.</P>
<PRE><CODE class="lang-js">// Much better!

const cluster = require('cluster');
const PORT = +process.env.PORT || 1337;

if (cluster.isMaster) {
  // In real life, you'd probably use more than just 2 workers,
  // and perhaps not put the master and worker in the same file.
  //
  // You can also of course get a bit fancier about logging, and
  // implement whatever custom logic you need to prevent DoS
  // attacks and other bad behavior.
  //
  // See the options in the cluster documentation.
  //
  // The important thing is that the master does very little,
  // increasing our resilience to unexpected errors.

  cluster.fork();
  cluster.fork();

  cluster.on('disconnect', (worker) =&gt; {
    console.error('disconnect!');
    cluster.fork();
  });

} else {
  // the worker
  //
  // This is where we put our bugs!

  const domain = require('domain');

  // See the cluster documentation for more details about using
  // worker processes to serve requests.  How it works, caveats, etc.

  const server = require('http').createServer((req, res) =&gt; {
    const d = domain.create();
    d.on('error', (er) =&gt; {
      console.error(`error ${er.stack}`);

      // Note: we're in dangerous territory!
      // By definition, something unexpected occurred,
      // which we probably didn't want.
      // Anything can happen now!  Be very careful!

      try {
        // make sure we close down within 30 seconds
        const killtimer = setTimeout(() =&gt; {
          process.exit(1);
        }, 30000);
        // But don't keep the process open just for that!
        killtimer.unref();

        // stop taking new requests.
        server.close();

        // Let the master know we're dead.  This will trigger a
        // 'disconnect' in the cluster master, and then it will fork
        // a new worker.
        cluster.worker.disconnect();

        // try to send an error to the request that triggered the problem
        res.statusCode = 500;
        res.setHeader('content-type', 'text/plain');
        res.end('Oops, there was a problem!\n');
      } catch (er2) {
        // oh well, not much we can do at this point.
        console.error(`Error sending 500! ${er2.stack}`);
      }
    });

    // Because req and res were created before this domain existed,
    // we need to explicitly add them.
    // See the explanation of implicit vs explicit binding below.
    d.add(req);
    d.add(res);

    // Now run the handler function in the domain.
    d.run(() =&gt; {
      handleRequest(req, res);
    });
  });
  server.listen(PORT);
}

// This part is not important.  Just an example routing thing.
// You'd put your fancy application logic here.
function handleRequest(req, res) {
  switch (req.url) {
    case '/error':
      // We do some async stuff, and then...
      setTimeout(() =&gt; {
        // Whoops!
        flerb.bark();
      });
      break;
    default:
      res.end('ok');
  }
}
</CODE></PRE>
<H2>Additions to Error objects<SPAN><A class="mark" id="domain_additions_to_error_objects" 
href="http://nodejs.cn/api/domain.html#domain_additions_to_error_objects">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_additions_to_error_objects">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/additions_to_error_objects.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>Any time an <CODE>Error</CODE> object is routed through a domain, a few extra 
fields are added to it.</P>
<UL>
  <LI><CODE>error.domain</CODE> The domain that first handled the error.</LI>
  <LI><CODE>error.domainEmitter</CODE> The event emitter that emitted an 
  <CODE>'error'</CODE> event with the error object.</LI>
  <LI><CODE>error.domainBound</CODE> The callback function which was bound to 
  the domain, and passed an error as its first argument.</LI>
  <LI><CODE>error.domainThrown</CODE> A boolean indicating whether the error was
   thrown, emitted, or passed to a bound callback function.</LI></UL>
<H2>Implicit Binding<SPAN><A class="mark" id="domain_implicit_binding" href="http://nodejs.cn/api/domain.html#domain_implicit_binding">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_implicit_binding">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/implicit_binding.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>If domains are in use, then all <STRONG>new</STRONG> EventEmitter objects 
(including Stream objects, requests, responses, etc.) will be implicitly bound 
to the active domain at the time of their creation.</P>
<P>Additionally, callbacks passed to lowlevel event loop requests (such as to 
fs.open, or other callback-taking methods) will automatically be bound to the 
active domain.  If they throw, then the domain will catch the error.</P>
<P>In order to prevent excessive memory usage, Domain objects themselves are not 
implicitly added as children of the active domain.  If they were, then it would 
be too easy to prevent request and response objects from being properly garbage 
collected.</P>
<P>If you <EM>want</EM> to nest Domain objects as children of a parent Domain,
 then you must explicitly add them.</P>
<P>Implicit binding routes thrown errors and <CODE>'error'</CODE> events to the
 Domain's <CODE>'error'</CODE> event, but does not register the EventEmitter on 
the Domain, so <A 
href="http://nodejs.cn/api/domain.html#domain_domain_dispose"><CODE>domain.dispose()</CODE></A> 
will not shut down the EventEmitter. Implicit binding only takes care of thrown 
errors and <CODE>'error'</CODE> events.</P>
<H2>Explicit Binding<SPAN><A class="mark" id="domain_explicit_binding" href="http://nodejs.cn/api/domain.html#domain_explicit_binding">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_explicit_binding">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/explicit_binding.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>Sometimes, the domain in use is not the one that ought to be used for a
 specific event emitter.  Or, the event emitter could have been created in the 
context of one domain, but ought to instead be bound to some other domain.</P>
<P>For example, there could be one domain in use for an HTTP server, but perhaps 
we would like to have a separate domain to use for each request.</P>
<P>That is possible via explicit binding.</P>
<P>For example:</P>
<PRE><CODE class="lang-js">// create a top-level domain for the server
const domain = require('domain');
const http = require('http');
const serverDomain = domain.create();

serverDomain.run(() =&gt; {
  // server is created in the scope of serverDomain
  http.createServer((req, res) =&gt; {
    // req and res are also created in the scope of serverDomain
    // however, we'd prefer to have a separate domain for each request.
    // create it first thing, and add req and res to it.
    const reqd = domain.create();
    reqd.add(req);
    reqd.add(res);
    reqd.on('error', (er) =&gt; {
      console.error('Error', er, req.url);
      try {
        res.writeHead(500);
        res.end('Error occurred, sorry.');
      } catch (er2) {
        console.error('Error sending 500', er2, req.url);
      }
    });
  }).listen(1337);
});
</CODE></PRE>
<H2>domain.create()<SPAN><A class="mark" id="domain_domain_create" href="http://nodejs.cn/api/domain.html#domain_domain_create">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_create">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_create.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI>Returns: <SPAN class="type">&lt;Domain&gt;</SPAN></LI></UL></DIV>
<P>Returns a new Domain object.</P>
<H2>Class: Domain<SPAN><A class="mark" id="domain_class_domain" href="http://nodejs.cn/api/domain.html#domain_class_domain">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_class_domain">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/class_domain.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>The Domain class encapsulates the functionality of routing errors and
 uncaught exceptions to the active Domain object.</P>
<P>Domain is a child class of <A href="http://nodejs.cn/api/events.html#events_class_eventemitter"><CODE>EventEmitter</CODE></A>. 
 To handle the errors that it catches, listen to its <CODE>'error'</CODE> 
event.</P>
<H3>domain.run(fn[, ...args])<SPAN><A class="mark" id="domain_domain_run_fn_args" 
href="http://nodejs.cn/api/domain.html#domain_domain_run_fn_args">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_run_fn_args">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_run_fn_args.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>fn</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI>
  <LI><CODE>...args</CODE> <SPAN class="type">&lt;any&gt;</SPAN></LI></UL></DIV>
<P>Run the supplied function in the context of the domain, implicitly binding 
all event emitters, timers, and lowlevel requests that are created in that 
context. Optionally, arguments can be passed to the function.</P>
<P>This is the most basic way to use a domain.</P>
<P>Example:</P>
<PRE><CODE class="lang-js">const domain = require('domain');
const fs = require('fs');
const d = domain.create();
d.on('error', (er) =&gt; {
  console.error('Caught error!', er);
});
d.run(() =&gt; {
  process.nextTick(() =&gt; {
    setTimeout(() =&gt; { // simulating some various async stuff
      fs.open('non-existent file', 'r', (er, fd) =&gt; {
        if (er) throw er;
        // proceed...
      });
    }, 100);
  });
});
</CODE></PRE>
<P>In this example, the <CODE>d.on('error')</CODE> handler will be triggered, 
rather than crashing the program.</P>
<H3>domain.members<SPAN><A class="mark" id="domain_domain_members" href="http://nodejs.cn/api/domain.html#domain_domain_members">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_members">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_members.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL></DIV>
<P>An array of timers and event emitters that have been explicitly added to the 
domain.</P>
<H3>domain.add(emitter)<SPAN><A class="mark" id="domain_domain_add_emitter" 
href="http://nodejs.cn/api/domain.html#domain_domain_add_emitter">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_add_emitter">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_add_emitter.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>emitter</CODE> <A class="type" href="http://nodejs.cn/api/events.html#events_class_eventemitter">&lt;EventEmitter&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/timers.html#timers_timers">&lt;Timer&gt;</A> 
  emitter or timer to be added to the domain</LI></UL></DIV>
<P>Explicitly adds an emitter to the domain.  If any event handlers called by
 the emitter throw an error, or if the emitter emits an <CODE>'error'</CODE> 
event, it will be routed to the domain's <CODE>'error'</CODE> event, just like 
with implicit binding.</P>
<P>This also works with timers that are returned from <A href="http://nodejs.cn/api/timers.html#timers_setinterval_callback_delay_args"><CODE>setInterval()</CODE></A> 
and <A href="http://nodejs.cn/api/timers.html#timers_settimeout_callback_delay_args"><CODE>setTimeout()</CODE></A>. 
 If their callback function throws, it will be caught by the domain 'error' 
handler.</P>
<P>If the Timer or EventEmitter was already bound to a domain, it is removed
 from that one, and bound to this one instead.</P>
<H3>domain.remove(emitter)<SPAN><A class="mark" id="domain_domain_remove_emitter" 
href="http://nodejs.cn/api/domain.html#domain_domain_remove_emitter">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_remove_emitter">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_remove_emitter.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>emitter</CODE> <A class="type" href="http://nodejs.cn/api/events.html#events_class_eventemitter">&lt;EventEmitter&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/timers.html#timers_timers">&lt;Timer&gt;</A> 
  emitter or timer to be removed from the domain</LI></UL></DIV>
<P>The opposite of <A href="http://nodejs.cn/api/domain.html#domain_domain_add_emitter"><CODE>domain.add(emitter)</CODE></A>. 
 Removes domain handling from the specified emitter.</P>
<H3>domain.bind(callback)<SPAN><A class="mark" id="domain_domain_bind_callback" 
href="http://nodejs.cn/api/domain.html#domain_domain_bind_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_bind_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_bind_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  The callback function</LI>
  <LI>Returns: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  The bound function</LI></UL></DIV>
<P>The returned function will be a wrapper around the supplied callback
 function.  When the returned function is called, any errors that are thrown 
will be routed to the domain's <CODE>'error'</CODE> event.</P>
<H4>Example<SPAN><A class="mark" id="domain_example" href="http://nodejs.cn/api/domain.html#domain_example">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_example">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/example.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE><CODE class="lang-js">const d = domain.create();

function readSomeFile(filename, cb) {
  fs.readFile(filename, 'utf8', d.bind((er, data) =&gt; {
    // if this throws, it will also be passed to the domain
    return cb(er, data ? JSON.parse(data) : null);
  }));
}

d.on('error', (er) =&gt; {
  // an error occurred somewhere.
  // if we throw it now, it will crash the program
  // with the normal line number and stack message.
});
</CODE></PRE>
<H3>domain.intercept(callback)<SPAN><A class="mark" id="domain_domain_intercept_callback" 
href="http://nodejs.cn/api/domain.html#domain_domain_intercept_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_intercept_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_intercept_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="signature">
<UL>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  The callback function</LI>
  <LI>Returns: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  The intercepted function</LI></UL></DIV>
<P>This method is almost identical to <A href="http://nodejs.cn/api/domain.html#domain_domain_bind_callback"><CODE>domain.bind(callback)</CODE></A>. 
 However, in addition to catching thrown errors, it will also intercept <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A>
 objects sent as the first argument to the function.</P>
<P>In this way, the common <CODE>if (err) return callback(err);</CODE> pattern 
can be replaced with a single error handler in a single place.</P>
<H4>Example<SPAN><A class="mark" id="domain_example_1" href="http://nodejs.cn/api/domain.html#domain_example_1">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_example_1">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/example_1.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE><CODE class="lang-js">const d = domain.create();

function readSomeFile(filename, cb) {
  fs.readFile(filename, 'utf8', d.intercept((data) =&gt; {
    // note, the first argument is never passed to the
    // callback since it is assumed to be the 'Error' argument
    // and thus intercepted by the domain.

    // if this throws, it will also be passed to the domain
    // so the error-handling logic can be moved to the 'error'
    // event on the domain instead of being repeated throughout
    // the program.
    return cb(null, JSON.parse(data));
  }));
}

d.on('error', (er) =&gt; {
  // an error occurred somewhere.
  // if we throw it now, it will crash the program
  // with the normal line number and stack message.
});
</CODE></PRE>
<H3>domain.enter()<SPAN><A class="mark" id="domain_domain_enter" href="http://nodejs.cn/api/domain.html#domain_domain_enter">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_enter">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_enter.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>The <CODE>enter</CODE> method is plumbing used by the <CODE>run</CODE>, 
<CODE>bind</CODE>, and <CODE>intercept</CODE> methods to set the active domain. 
It sets <CODE>domain.active</CODE> and <CODE>process.domain</CODE> to the 
domain, and implicitly pushes the domain onto the domain stack managed by the 
domain module (see <A 
href="http://nodejs.cn/api/domain.html#domain_domain_exit"><CODE>domain.exit()</CODE></A> 
for details on the domain stack). The call to <CODE>enter</CODE> delimits the 
beginning of a chain of asynchronous calls and I/O operations bound to a 
domain.</P>
<P>Calling <CODE>enter</CODE> changes only the active domain, and does not alter 
the domain itself. <CODE>enter</CODE> and <CODE>exit</CODE> can be called an 
arbitrary number of times on a single domain.</P>
<P>If the domain on which <CODE>enter</CODE> is called has been disposed, 
<CODE>enter</CODE> will return without setting the domain.</P>
<H3>domain.exit()<SPAN><A class="mark" id="domain_domain_exit" href="http://nodejs.cn/api/domain.html#domain_domain_exit">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_exit">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_exit.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>The <CODE>exit</CODE> method exits the current domain, popping it off the 
domain stack. Any time execution is going to switch to the context of a 
different chain of asynchronous calls, it's important to ensure that the current 
domain is exited. The call to <CODE>exit</CODE> delimits either the end of or an 
interruption to the chain of asynchronous calls and I/O operations bound to a 
domain.</P>
<P>If there are multiple, nested domains bound to the current execution context, 
<CODE>exit</CODE> will exit any domains nested within this domain.</P>
<P>Calling <CODE>exit</CODE> changes only the active domain, and does not alter 
the domain itself. <CODE>enter</CODE> and <CODE>exit</CODE> can be called an 
arbitrary number of times on a single domain.</P>
<P>If the domain on which <CODE>exit</CODE> is called has been disposed, 
<CODE>exit</CODE> will return without exiting the domain.</P>
<H3>domain.dispose()<SPAN><A class="mark" id="domain_domain_dispose" href="http://nodejs.cn/api/domain.html#domain_domain_dispose">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/domain.html#domain_domain_dispose">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/domain/domain_dispose.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_0"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">Stability: 0</A> - Deprecated.  Please recover from failed IO actions
explicitly via error event handlers set on the domain.</PRE>
<P>Once <CODE>dispose</CODE> has been called, the domain will no longer be used 
by callbacks bound into the domain via <CODE>run</CODE>, <CODE>bind</CODE>, or 
<CODE>intercept</CODE>, and a <CODE>'dispose'</CODE> event is 
emitted.</P></DIV></DIV></DIV><!-- 搜索弹窗 -->   
<DIV id="modal_search_bg"></DIV>
<DIV 
id="modal_search"><INPUT id="modal_search_input" placeholder="API 快速搜索" value=""> 
    
<DIV id="modal_search_result"></DIV></DIV><!-- js -->   <!--[if lt IE 10]><script src="/static/lib/placeholders.js?20170426"></script><![endif]--> 
  
<SCRIPT src="domain%20%20Node_js%20API%20文档_files/api.js"></SCRIPT>
 </BODY></HTML>
