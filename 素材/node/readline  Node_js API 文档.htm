<!DOCTYPE HTML>
<!-- saved from url=(0034)http://nodejs.cn/api/readline.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cmn-Hans"><HEAD><META 
content="IE=11.0000" http-equiv="X-UA-Compatible">
   
<META charset="utf-8">   <TITLE>readline | Node.js API 文档</TITLE>   <LINK href="readline%20%20Node_js%20API%20文档_files/api.css" 
rel="stylesheet">   <LINK href="/static/favicon.png" rel="icon" type="image/png" 
sizes="32x32"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18639"></HEAD> 
<BODY class="alt apidoc" id="api-section-readline">
<DIV class="clearfix" id="content">
<DIV class="interior" id="column2">
<DIV class="interior" id="intro"><A href="http://nodejs.cn/">          Node.js 
中文网         </A>         
<DIV><INPUT id="search_input" placeholder="API 快速搜索" value="">         
</DIV></DIV>
<UL>
  <LI><A class="nav-documentation" href="http://nodejs.cn/api/documentation.html">关于本文档</A></LI>
  <LI><A class="nav-synopsis" 
  href="http://nodejs.cn/api/synopsis.html">用法与例子</A></LI></UL>
<DIV class="line"></DIV>
<UL>
  <LI><A class="nav-assert" href="http://nodejs.cn/api/assert.html">Assert 
  (断言)</A></LI>
  <LI><A class="nav-buffer" 
  href="http://nodejs.cn/api/buffer.html">Buffer</A></LI>
  <LI><A class="nav-addons" href="http://nodejs.cn/api/addons.html">C/C++ 
  插件</A></LI>
  <LI><A class="nav-child_process" href="http://nodejs.cn/api/child_process.html">Child 
  Processes (子进程)</A></LI>
  <LI><A class="nav-cluster" href="http://nodejs.cn/api/cluster.html">Cluster 
  (集群)</A></LI>
  <LI><A class="nav-cli" href="http://nodejs.cn/api/cli.html">CLI 
  (命令行选项)</A></LI>
  <LI><A class="nav-console" href="http://nodejs.cn/api/console.html">Console 
  (控制台)</A></LI>
  <LI><A class="nav-crypto" href="http://nodejs.cn/api/crypto.html">Crypto 
  (加密)</A></LI>
  <LI><A class="nav-debugger" href="http://nodejs.cn/api/debugger.html">Debugger 
  (调试器)</A></LI>
  <LI><A class="nav-dns" href="http://nodejs.cn/api/dns.html">DNS 
  (域名服务器)</A></LI>
  <LI><A class="nav-domain" href="http://nodejs.cn/api/domain.html">Domain 
  (域)</A></LI>
  <LI><A class="nav-errors" href="http://nodejs.cn/api/errors.html">Error 
  (错误)</A></LI>
  <LI><A class="nav-events" href="http://nodejs.cn/api/events.html">Events 
  (事件)</A></LI>
  <LI><A class="nav-fs" href="http://nodejs.cn/api/fs.html">File System 
  (文件系统)</A></LI>
  <LI><A class="nav-globals" href="http://nodejs.cn/api/globals.html">Global 
  (全局变量)</A></LI>
  <LI><A class="nav-http" href="http://nodejs.cn/api/http.html">HTTP</A></LI>
  <LI><A class="nav-https" href="http://nodejs.cn/api/https.html">HTTPS</A></LI>
  <LI><A class="nav-modules" href="http://nodejs.cn/api/modules.html">Module 
  (模块)</A></LI>
  <LI><A class="nav-net" href="http://nodejs.cn/api/net.html">Net (网络)</A></LI>
  <LI><A class="nav-os" href="http://nodejs.cn/api/os.html">OS (操作系统)</A></LI>
  <LI><A class="nav-path" href="http://nodejs.cn/api/path.html">Path 
  (路径)</A></LI>
  <LI><A class="nav-process" href="http://nodejs.cn/api/process.html">Process 
  (进程)</A></LI>
  <LI><A class="nav-punycode" 
  href="http://nodejs.cn/api/punycode.html">Punycode</A></LI>
  <LI><A class="nav-querystring" 
  href="http://nodejs.cn/api/querystring.html">Query Strings (查询字符串)</A></LI>
  <LI><A class="nav-readline active" 
  href="http://nodejs.cn/api/readline.html">Readline (逐行读取)</A></LI>
  <LI><A class="nav-repl" href="http://nodejs.cn/api/repl.html">REPL 
  (交互式解释器)</A></LI>
  <LI><A class="nav-stream" href="http://nodejs.cn/api/stream.html">Stream 
  (流)</A></LI>
  <LI><A class="nav-string_decoder" href="http://nodejs.cn/api/string_decoder.html">String 
  Decoder (字符串解码器)</A></LI>
  <LI><A class="nav-timers" href="http://nodejs.cn/api/timers.html">Timer 
  (定时器)</A></LI>
  <LI><A class="nav-tls" href="http://nodejs.cn/api/tls.html">TLS 
  (安全传输层)</A></LI>
  <LI><A class="nav-tty" href="http://nodejs.cn/api/tty.html">TTY (终端)</A></LI>
  <LI><A class="nav-dgram" href="http://nodejs.cn/api/dgram.html">UDP/Datagram 
  (数据报)</A></LI>
  <LI><A class="nav-url" href="http://nodejs.cn/api/url.html">URL</A></LI>
  <LI><A class="nav-util" href="http://nodejs.cn/api/util.html">Util 
  (实用工具)</A></LI>
  <LI><A class="nav-v8" href="http://nodejs.cn/api/v8.html">V8</A></LI>
  <LI><A class="nav-vm" href="http://nodejs.cn/api/vm.html">VM (虚拟机)</A></LI>
  <LI><A class="nav-zlib" href="http://nodejs.cn/api/zlib.html">ZLIB 
  (压缩)</A></LI></UL>
<DIV class="line"></DIV></DIV>
<DIV class="interior" id="column1" data-id="readline"><HEADER>
<H1>Node.js v6.10.3 文档</H1>
<DIV id="gtoc">
<P><A name="toc" href="http://nodejs.cn/api/">返回文档首页</A>             <!--<a href="/api/all.html">单页面显示</a> |--> 
            <!--<a href="/api/readline.json">JSON格式</a> |-->             <!--<a href="/api/en/readline.html">查看英文版</a>--> 
          </P></DIV>
<HR>
</HEADER>
<DIV id="toc">
<H2>目录</H2>
<UL>
  <LI><SPAN class="stability_2"><A href="http://nodejs.cn/api/readline.html#readline_readline">readline 
  (逐行读取)</A></SPAN>
  <UL> 
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_class_interface">Interface 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_close">'close' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_line">'line' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_pause">'pause' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_resume">'resume' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_sigcont">'SIGCONT' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_sigint">'SIGINT' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_event_sigtstp">'SIGTSTP' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_close">rl.close()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_pause">rl.pause()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_prompt_preservecursor">rl.prompt([preserveCursor])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_question_query_callback">rl.question(query, 
      callback)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_resume">rl.resume()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_setprompt_prompt">rl.setPrompt(prompt)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_rl_write_data_key">rl.write(data[, 
      key])</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_clearline_stream_dir">readline.clearLine(stream, 
    dir)</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_clearscreendown_stream">readline.clearScreenDown(stream)</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_createinterface_options">readline.createInterface(options)</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_use_of_the_completer_function"><CODE>completer</CODE> 
      函数的使用</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_cursorto_stream_x_y">readline.cursorTo(stream, 
    x, y)</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_emitkeypressevents_stream_interface">readline.emitKeypressEvents(stream[, 
    interface])</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_readline_movecursor_stream_dx_dy">readline.moveCursor(stream, 
    dx, dy)</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_example_tiny_cli">例子：简单的命令行界面</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/readline.html#readline_example_read_file_stream_line_by_line">例子：逐行地读取文件流</A></SPAN></LI></UL></LI></UL></DIV>
<DIV id="apicontent">
<H1>readline (逐行读取)<SPAN><A class="mark" id="readline_readline" href="http://nodejs.cn/api/readline.html#readline_readline">#</A></SPAN></H1>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_2"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 2</A> - 稳定的</PRE>
<P><CODE>require('readline')</CODE> 模块提供了一个接口，用于从<A href="http://nodejs.cn/api/stream.html#stream_readable_streams">可读流</A>（如 
<A 
href="http://nodejs.cn/api/process.html#process_process_stdin"><CODE>process.stdin</CODE></A>）读取数据，每次读取一行。
 它可以通过以下方式使用：</P>
<PRE><CODE class="lang-js">const readline = require('readline');
</CODE></PRE>
<P>例子，<CODE>readline</CODE> 模块的基本用法：</P>
<PRE><CODE class="lang-js">const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.question('你认为 Node.js 中文网怎么样？', (answer) =&gt; {
  // 对答案进行处理
  console.log(`多谢你的反馈：${answer}`);

  rl.close();
});
</CODE></PRE>
<P>注意，当调用该代码时，Node.js 程序不会终止，直到 <CODE>readline.Interface</CODE> 被关闭，因为接口在等待 
<CODE>input</CODE> 流中要被接收的数据。</P>
<H2>Interface 类<SPAN><A class="mark" id="readline_class_interface" href="http://nodejs.cn/api/readline.html#readline_class_interface">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_class_interface">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/class_interface.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.104</SPAN> </DIV>
<P><CODE>readline.Interface</CODE> 类的实例是使用 
<CODE>readline.createInterface()</CODE> 方法构造的。 每个实例都关联一个 <CODE>input</CODE> <A 
href="http://nodejs.cn/api/stream.html#stream_readable_streams">可读流</A>和一个 
<CODE>output</CODE> <A href="http://nodejs.cn/api/stream.html#stream_writable_streams">可写流</A>。 
<CODE>output</CODE> 流用于为到达的用户输入打印提示，且从 <CODE>input</CODE> 流读取。</P>
<H3>'close' 事件<SPAN><A class="mark" id="readline_event_close" href="http://nodejs.cn/api/readline.html#readline_event_close">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_close">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_close.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<P>当以下之一发生时，触发 <CODE>'close'</CODE> 事件：</P>
<UL>
  <LI><CODE>rl.close()</CODE> 方法被调用，且 <CODE>readline.Interface</CODE> 实例已撤回对 
  <CODE>input</CODE> 流和 <CODE>output</CODE> 流的控制；</LI>
  <LI><CODE>input</CODE> 流接收到 <CODE>'end'</CODE> 事件；</LI>
  <LI><CODE>input</CODE> 流接收到表示结束传输的 <CODE>&lt;ctrl&gt;-D</CODE>；</LI>
  <LI><CODE>input</CODE> 流接收到表示 <CODE>SIGINT</CODE> 的 
  <CODE>&lt;ctrl&gt;-C</CODE>，且 <CODE>readline.Interface</CODE> 实例上没有注册 
  <CODE>SIGINT</CODE> 事件监听器。</LI></UL>
<P>监听器函数被调用时不传入任何参数。</P>
<P>当 <CODE>'close'</CODE> 事件被触发时，<CODE>readline.Interface</CODE> 实例应当被视为已结束。</P>
<H3>'line' 事件<SPAN><A class="mark" id="readline_event_line" href="http://nodejs.cn/api/readline.html#readline_event_line">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_line">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_line.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<P>每当 <CODE>input</CODE> 流接收到接收行结束符（<CODE>\n</CODE>、<CODE>\r</CODE> 或 
<CODE>\r\n</CODE>）时触发 <CODE>'line'</CODE> 事件。 通常发生在用户按下 
<CODE>&lt;Enter&gt;</CODE> 键或 <CODE>&lt;Return&gt;</CODE> 键。</P>
<P>监听器函数被调用时会带上一个包含接收的那一行输入的字符串。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('line', (input) =&gt; {
  console.log(`接收到：${input}`);
});
</CODE></PRE>
<H3>'pause' 事件<SPAN><A class="mark" id="readline_event_pause" href="http://nodejs.cn/api/readline.html#readline_event_pause">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_pause">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_pause.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.5</SPAN> </DIV>
<P>当以下之一发生时触发 <CODE>'pause'</CODE> 事件：</P>
<UL>
  <LI><CODE>input</CODE> 流被暂停。</LI>
  <LI><CODE>input</CODE> 流不是暂停的，且接收到 <CODE>SIGCONT</CODE> 事件。（详见 <A href="http://nodejs.cn/api/readline.html#readline_event_sigtstp"><CODE>SIGTSTP</CODE></A> 
  事件和 <A 
  href="http://nodejs.cn/api/readline.html#readline_event_sigcont"><CODE>SIGCONT</CODE></A> 
  事件）</LI></UL>
<P>监听器函数被调用时不传入任何参数。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('pause', () =&gt; {
  console.log('Readline 被暂停。');
});
</CODE></PRE>
<H3>'resume' 事件<SPAN><A class="mark" id="readline_event_resume" href="http://nodejs.cn/api/readline.html#readline_event_resume">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_resume">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_resume.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.5</SPAN> </DIV>
<P>每当 <CODE>input</CODE> 流被恢复时触发 <CODE>'resume'</CODE> 事件。</P>
<P>监听器函数被调用时不传入任何参数。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('resume', () =&gt; {
  console.log('Readline 被恢复。');
});
</CODE></PRE>
<H3>'SIGCONT' 事件<SPAN><A class="mark" id="readline_event_sigcont" href="http://nodejs.cn/api/readline.html#readline_event_sigcont">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_sigcont">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_sigcont.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.5</SPAN> </DIV>
<P>当一个 Node.js 进程使用 <CODE>&lt;ctrl&gt;-Z</CODE>（也就是 
<CODE>SIGTSTP</CODE>）移入后台之后再使用 <A href="http://man7.org/linux/man-pages/man1/fg.1.html">fg(1)</A> 
移回前台时，触发 <CODE>'SIGCONT'</CODE> 事件。</P>
<P>如果 <CODE>input</CODE> 流在 <CODE>SIGTSTP</CODE> 请求之前被暂停，则事件不会被触发。</P>
<P>监听器函数被调用时不传入任何参数。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('SIGCONT', () =&gt; {
  // `prompt` 会自动恢复流
  rl.prompt();
});
</CODE></PRE>
<P>注意：Windows 系统不支持 <CODE>'SIGCONT'</CODE> 事件。</P>
<H3>'SIGINT' 事件<SPAN><A class="mark" id="readline_event_sigint" href="http://nodejs.cn/api/readline.html#readline_event_sigint">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_sigint">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_sigint.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<P>每当 <CODE>input</CODE> 流接收到一个 <CODE>&lt;ctrl&gt;-C</CODE> 输入（通常被称为 
<CODE>SIGINT</CODE>）时，触发 <CODE>'SIGINT'</CODE> 事件。 当 <CODE>input</CODE> 流接收到一个 
<CODE>SIGINT</CODE> 时，如果没有注册 <CODE>'SIGINT'</CODE> 事件监听器，则 <CODE>'pause'</CODE> 
事件会被触发。</P>
<P>监听器函数被调用时不传入任何参数。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('SIGINT', () =&gt; {
  rl.question('确定要退出吗？', (answer) =&gt; {
    if (answer.match(/^y(es)?$/i)) rl.pause();
  });
});
</CODE></PRE>
<H3>'SIGTSTP' 事件<SPAN><A class="mark" id="readline_event_sigtstp" href="http://nodejs.cn/api/readline.html#readline_event_sigtstp">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_event_sigtstp">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/event_sigtstp.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.5</SPAN> </DIV>
<P>每当 <CODE>input</CODE> 流接收到一个 <CODE>&lt;ctrl&gt;-Z</CODE> 输入（通常被称为 
<CODE>SIGTSTP</CODE>）时，触发 <CODE>'SIGTSTP'</CODE> 事件。 当 <CODE>input</CODE> 流接收到一个 
<CODE>SIGTSTP</CODE> 时，如果没有注册 <CODE>'SIGTSTP'</CODE> 事件监听器，则 Node.js 
进程会被发送到后台。</P>
<P>当程序使用 <A href="http://man7.org/linux/man-pages/man1/fg.1.html">fg(1)</A> 
恢复时，<CODE>'pause'</CODE> 和 <CODE>SIGCONT</CODE> 事件会被触发。 这可被用来恢复 
<CODE>input</CODE> 流。</P>
<P>如果 <CODE>input</CODE> 流在进程被发送到后台之前被暂停，则 <CODE>'pause'</CODE> 和 
<CODE>SIGCONT</CODE> 事件不会被触发。</P>
<P>监听器函数被调用时不传入任何参数。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.on('SIGTSTP', () =&gt; {
  // 这会重写 SIGTSTP，且防止程序进入后台。
  console.log('捕获 SIGTSTP。');
});
</CODE></PRE>
<P>注意：Windows 系统不支持 <CODE>'SIGTSTP'</CODE> 事件。</P>
<H3>rl.close()<SPAN><A class="mark" id="readline_rl_close" href="http://nodejs.cn/api/readline.html#readline_rl_close">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_close">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_close.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<P><CODE>rl.close()</CODE> 方法会关闭 <CODE>readline.Interface</CODE> 实例，且撤回对 
<CODE>input</CODE> 和 <CODE>output</CODE> 流的控制。 但被调用时，<CODE>'close'</CODE> 
事件会被触发。</P>
<H3>rl.pause()<SPAN><A class="mark" id="readline_rl_pause" href="http://nodejs.cn/api/readline.html#readline_rl_pause">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_pause">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_pause.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.4</SPAN> </DIV>
<P><CODE>rl.pause()</CODE> 方法会暂停 <CODE>input</CODE> 流，且稍后需要时可被恢复。</P>
<P>调用 <CODE>rl.pause()</CODE> 不会立刻暂停其他事件（包括 <CODE>'line'</CODE>）被 
<CODE>readline.Interface</CODE> 实例触发。</P>
<H3>rl.prompt([preserveCursor])<SPAN><A class="mark" id="readline_rl_prompt_preservecursor" 
href="http://nodejs.cn/api/readline.html#readline_rl_prompt_preservecursor">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_prompt_preservecursor">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_prompt_preservecursor.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<UL>
  <LI><CODE>preserveCursor</CODE> <SPAN class="type">&lt;boolean&gt;</SPAN> 如果为 
  <CODE>true</CODE>，则阻止光标落点被设为 <CODE>0</CODE>。</LI></UL>
<P><CODE>rl.prompt()</CODE> 方法会在 <CODE>output</CODE> 流中新的一行写入 
<CODE>readline.Interface</CODE> 实例配置后的 
<CODE>prompt</CODE>，用于为用户提供一个可供输入的新的位置。</P>
<P>当被调用时，如果 <CODE>input</CODE> 流已被暂停，则 <CODE>rl.prompt()</CODE> 会恢复 
<CODE>input</CODE> 流。</P>
<P>如果 <CODE>readline.Interface</CODE> 被创建时 <CODE>output</CODE> 被设为 
<CODE>null</CODE> 或 <CODE>undefined</CODE>，则提示不会被写入。</P>
<H3>rl.question(query, callback)<SPAN><A class="mark" id="readline_rl_question_query_callback" 
href="http://nodejs.cn/api/readline.html#readline_rl_question_query_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_question_query_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_question_query_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.3</SPAN> </DIV>
<UL>
  <LI><CODE>query</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  一个在提示符之前、要写入 <CODE>output</CODE> 的叙述或询问。</LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  一个回调函数，它会被调用并带上用户响应 <CODE>query</CODE> 的输入。</LI></UL>
<P><CODE>rl.question()</CODE> 方法通过写入到 <CODE>output</CODE> 来展示 
<CODE>query</CODE>，并等待用户提供到 <CODE>input</CODE> 的输入，然后调用 <CODE>callback</CODE> 
函数并传入提供的输入作为第一个参数。</P>
<P>当被调用时，如果 <CODE>input</CODE> 流已被暂停，则 <CODE>rl.question()</CODE> 会恢复 
<CODE>input</CODE> 流。</P>
<P>如果 <CODE>readline.Interface</CODE> 被创建时 <CODE>output</CODE> 被设为 
<CODE>null</CODE> 或 <CODE>undefined</CODE>，则 <CODE>query</CODE> 不会被写入。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.question('你最喜欢的食物是什么？', (answer) =&gt; {
  console.log(`你最喜欢的食物是 ${answer}`);
});
</CODE></PRE>
<P>注意：传入的 <CODE>rl.question()</CODE> 的 <CODE>callback</CODE> 函数不遵循接受一个 
<CODE>Error</CODE> 对象或 <CODE>null</CODE> 作为第一个参数的标准模式。 <CODE>callback</CODE> 
被调用时只带上提供的答案作为唯一的参数。</P>
<H3>rl.resume()<SPAN><A class="mark" id="readline_rl_resume" href="http://nodejs.cn/api/readline.html#readline_rl_resume">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_resume">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_resume.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.4</SPAN> </DIV>
<P>如果 <CODE>input</CODE> 流已被暂停，则 <CODE>rl.resume()</CODE> 方法会恢复 
<CODE>input</CODE> 流。</P>
<H3>rl.setPrompt(prompt)<SPAN><A class="mark" id="readline_rl_setprompt_prompt" 
href="http://nodejs.cn/api/readline.html#readline_rl_setprompt_prompt">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_setprompt_prompt">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_setprompt_prompt.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<UL>
  <LI><CODE>prompt</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P><CODE>rl.setPrompt()</CODE> 方法用于设置每当 <CODE>rl.prompt()</CODE> 被调用时要被写入到 
<CODE>output</CODE> 的提示。</P>
<H3>rl.write(data[, key])<SPAN><A class="mark" id="readline_rl_write_data_key" 
href="http://nodejs.cn/api/readline.html#readline_rl_write_data_key">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_rl_write_data_key">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/rl_write_data_key.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<UL>
  <LI><CODE>data</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>key</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>ctrl</CODE> <SPAN class="type">&lt;boolean&gt;</SPAN> 如果为 
    <CODE>true</CODE> 则表示 <CODE>&lt;ctrl&gt;</CODE> 键。</LI>
    <LI><CODE>meta</CODE> <SPAN class="type">&lt;boolean&gt;</SPAN> 如果为 
    <CODE>true</CODE> 则表示 <CODE>&lt;Meta&gt;</CODE> 键。</LI>
    <LI><CODE>shift</CODE> <SPAN class="type">&lt;boolean&gt;</SPAN> 如果为 
    <CODE>true</CODE> 则表示 <CODE>&lt;Shift&gt;</CODE> 键。</LI>
    <LI><CODE>name</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    一个按键的名称。</LI></UL></LI></UL>
<P><CODE>rl.write()</CODE> 方法会把 <CODE>data</CODE> 或一个由 <CODE>key</CODE> 
指定的按键序列写入到 <CODE>output</CODE>。 只有当 <CODE>output</CODE> 是一个 <A href="http://nodejs.cn/api/tty.html">TTY</A> 
文本终端时，<CODE>key</CODE> 参数才被支持。</P>
<P>如果指定了 <CODE>key</CODE>，则 <CODE>data</CODE> 会被忽略。</P>
<P>当被调用时，如果 <CODE>input</CODE> 流已被暂停，则 <CODE>rl.write()</CODE> 会恢复 
<CODE>input</CODE> 流。</P>
<P>如果 <CODE>readline.Interface</CODE> 被创建时 <CODE>output</CODE> 被设为 
<CODE>null</CODE> 或 <CODE>undefined</CODE>，则 <CODE>data</CODE> 和 
<CODE>key</CODE> 不会被写入。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">rl.write('删除这个！');
// 模拟 Ctrl+u 删除写入的前一行。
rl.write(null, {ctrl: true, name: 'u'});
</CODE></PRE>
<P>注意：<CODE>rl.write()</CODE> 方法会写入数据到 <CODE>readline</CODE> 接口的 
<CODE>input</CODE>，犹如它是用户提供的。</P>
<H2>readline.clearLine(stream, dir)<SPAN><A class="mark" id="readline_readline_clearline_stream_dir" 
href="http://nodejs.cn/api/readline.html#readline_readline_clearline_stream_dir">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_clearline_stream_dir">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_clearline_stream_dir.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>stream</CODE> <SPAN class="type">&lt;Writable&gt;</SPAN></LI>
  <LI><CODE>dir</CODE> <SPAN class="type">&lt;number&gt;</SPAN>
  <UL> 
    <LI><CODE>-1</CODE> - 光标左边</LI>
    <LI><CODE>1</CODE> - 光标右边</LI>
    <LI><CODE>0</CODE> - 整行</LI></UL></LI></UL>
<P><CODE>readline.clearLine()</CODE> 方法会以 <CODE>dir</CODE> 指定的方向清除给定的 <A href="http://nodejs.cn/api/tty.html">TTY</A> 
流的当前行。</P>
<H2>readline.clearScreenDown(stream)<SPAN><A class="mark" id="readline_readline_clearscreendown_stream" 
href="http://nodejs.cn/api/readline.html#readline_readline_clearscreendown_stream">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_clearscreendown_stream">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_clearscreendown_stream.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>stream</CODE> <SPAN class="type">&lt;Writable&gt;</SPAN></LI></UL>
<P><CODE>readline.clearScreenDown()</CODE> 方法会从光标的当前位置向下清除给定的 <A href="http://nodejs.cn/api/tty.html">TTY</A> 
流。</P>
<H2>readline.createInterface(options)<SPAN><A class="mark" id="readline_readline_createinterface_options" 
href="http://nodejs.cn/api/readline.html#readline_readline_createinterface_options">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_createinterface_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_createinterface_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.98</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>input</CODE> <SPAN class="type">&lt;Readable&gt;</SPAN> 要监听的<A 
    href="http://nodejs.cn/api/stream.html#stream_readable_streams">可读流</A>。该选项是必需的。</LI>
    <LI><CODE>output</CODE> <SPAN class="type">&lt;Writable&gt;</SPAN> 
    要写入逐行读取数据的<A 
    href="http://nodejs.cn/api/stream.html#stream_writable_streams">可写流</A>。</LI>
    <LI><CODE>completer</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
    一个可选的函数，用于 Tab 自动补全。</LI>
    <LI><CODE>terminal</CODE> <SPAN class="type">&lt;boolean&gt;</SPAN> 如果 
    <CODE>input</CODE> 和 <CODE>output</CODE> 应被当作一个 TTY，且要写入 ANSI/VT100 
    转换的代码，则设为 <CODE>true</CODE>。 默认为实例化时在 <CODE>output</CODE> 流上检查 
    <CODE>isTTY</CODE>。</LI>
    <LI><CODE>historySize</CODE> <SPAN class="type">&lt;number&gt;</SPAN> 
    保留的历史行数的最大数量。 设为 <CODE>0</CODE> 可禁用历史记录。 默认为 <CODE>30</CODE>。 该选项只有当 
    <CODE>terminal</CODE> 被用户或内部 <CODE>output</CODE> 设为 <CODE>true</CODE> 
    时才有意义，否则历史缓存机制不会被初始化。</LI>
    <LI><CODE>prompt</CODE> - 要使用的提示字符串。默认为 <CODE>'&gt; '</CODE>。</LI>
    <LI><CODE>crlfDelay</CODE> <SPAN class="type">&lt;number&gt;</SPAN> 如果 
    <CODE>\r</CODE> 与 <CODE>\n</CODE> 之间的延迟超过 <CODE>crlfDelay</CODE> 毫秒，则 
    <CODE>\r</CODE> 和 <CODE>\n</CODE> 都会被当作换行分隔符。 默认为 <CODE>100</CODE> 毫秒。 
    <CODE>crlfDelay</CODE> 的范围为 <CODE>[100, 2000]</CODE>。</LI></UL></LI></UL>
<P><CODE>readline.createInterface()</CODE> 方法会创建一个新的 
<CODE>readline.Interface</CODE> 实例。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});
</CODE></PRE>
<P>一旦 <CODE>readline.Interface</CODE> 实例被创建，最常见的用法是监听 <CODE>'line'</CODE> 
事件：</P>
<PRE><CODE class="lang-js">rl.on('line', (line) =&gt; {
  console.log(`接收到：${line}`);
});
</CODE></PRE>
<P>如果该实例的 <CODE>terminal</CODE> 为 <CODE>true</CODE>，则若它定义了一个 
<CODE>output.columns</CODE> 属性则 <CODE>output</CODE> 
流会获得最佳兼容性，且如果或当列发生变化时，<CODE>output</CODE> 上触发一个 <CODE>'resize'</CODE> 事件（当它为一个 
TTY 时，<A 
href="http://nodejs.cn/api/process.html#process_process_stdout"><CODE>process.stdout</CODE></A> 
会自动处理这个）。</P>
<H3><CODE>completer</CODE> 函数的使用<SPAN><A class="mark" id="readline_use_of_the_completer_function" 
href="http://nodejs.cn/api/readline.html#readline_use_of_the_completer_function">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_use_of_the_completer_function">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/use_of_the_completer_function.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>当被调用时，用户输入的当前行会被提供给 <CODE>completer</CODE> 函数，并返回一个包含以下两个条目的数组：</P>
<UL>
  <LI>一个包含匹配补全输入的数组。</LI>
  <LI>用于匹配的子字符串。</LI></UL>
<P>例如：<CODE>[[substr1, substr2, ...], originalsubstring]</CODE>。</P>
<PRE><CODE class="lang-js">function completer(line) {
  const completions = '.help .error .exit .quit .q'.split(' ');
  const hits = completions.filter((c) =&gt; { return c.indexOf(line) === 0 });
  // 如果没匹配到则展示全部补全
  return [hits.length ? hits : completions, line];
}
</CODE></PRE>
<P>如果 <CODE>completer</CODE> 函数接受两个参数，则可被异步地调用：</P>
<PRE><CODE class="lang-js">function completer(linePartial, callback) {
  callback(null, [['123'], linePartial]);
}
</CODE></PRE>
<H2>readline.cursorTo(stream, x, y)<SPAN><A class="mark" id="readline_readline_cursorto_stream_x_y" 
href="http://nodejs.cn/api/readline.html#readline_readline_cursorto_stream_x_y">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_cursorto_stream_x_y">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_cursorto_stream_x_y.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>stream</CODE> <SPAN class="type">&lt;Writable&gt;</SPAN></LI>
  <LI><CODE>x</CODE> <SPAN class="type">&lt;number&gt;</SPAN></LI>
  <LI><CODE>y</CODE> <SPAN class="type">&lt;number&gt;</SPAN></LI></UL>
<P><CODE>readline.cursorTo()</CODE> 方法会移动光标到给定的 <A href="http://nodejs.cn/api/tty.html">TTY</A> 
<CODE>stream</CODE> 中指定的位置。</P>
<H2>readline.emitKeypressEvents(stream[, interface])<SPAN><A class="mark" id="readline_readline_emitkeypressevents_stream_interface" 
href="http://nodejs.cn/api/readline.html#readline_readline_emitkeypressevents_stream_interface">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_emitkeypressevents_stream_interface">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_emitkeypressevents_stream_interface.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>stream</CODE> <SPAN class="type">&lt;Readable&gt;</SPAN></LI>
  <LI><CODE>interface</CODE> <SPAN 
  class="type">&lt;readline.Interface&gt;</SPAN></LI></UL>
<P><CODE>readline.emitKeypressEvents()</CODE> 方法使给定的<A href="http://nodejs.cn/api/stream.html#stream_writable_streams">可写流</A> 
<CODE>stream</CODE> 相应于接收到的输入触发 <CODE>'keypress'</CODE> 事件。</P>
<P>可选的 <CODE>interface</CODE> 指定了一个 <CODE>readline.Interface</CODE> 
实例，用于当自动补全被禁用时检测到复制粘贴输入。</P>
<P>如果 <CODE>stream</CODE> 是一个 <A 
href="http://nodejs.cn/api/tty.html">TTY</A>，则它必须为原始模式。</P>
<PRE><CODE class="lang-js">readline.emitKeypressEvents(process.stdin);
if (process.stdin.isTTY)
  process.stdin.setRawMode(true);
</CODE></PRE>
<H2>readline.moveCursor(stream, dx, dy)<SPAN><A class="mark" id="readline_readline_movecursor_stream_dx_dy" 
href="http://nodejs.cn/api/readline.html#readline_readline_movecursor_stream_dx_dy">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_readline_movecursor_stream_dx_dy">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/readline_movecursor_stream_dx_dy.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.7</SPAN> </DIV>
<UL>
  <LI><CODE>stream</CODE> <SPAN class="type">&lt;Writable&gt;</SPAN></LI>
  <LI><CODE>dx</CODE> <SPAN class="type">&lt;number&gt;</SPAN></LI>
  <LI><CODE>dy</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P><CODE>readline.moveCursor()</CODE> 方法会移动光标到给定的 <A href="http://nodejs.cn/api/tty.html">TTY</A> 
<CODE>stream</CODE> 中相对当前的位置。</P>
<H2>例子：简单的命令行界面<SPAN><A class="mark" id="readline_example_tiny_cli" href="http://nodejs.cn/api/readline.html#readline_example_tiny_cli">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_example_tiny_cli">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/example_tiny_cli.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>例子，使用 <CODE>readline.Interface</CODE> 类实现一个简单的命令行界面：</P>
<PRE><CODE class="lang-js">const readline = require('readline');
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  prompt: '请输入&gt; '
});

rl.prompt();

rl.on('line', (line) =&gt; {
  switch(line.trim()) {
    case 'hello':
      console.log('world!');
      break;
    default:
      console.log(`你输入的是：'${line.trim()}'`);
      break;
  }
  rl.prompt();
}).on('close', () =&gt; {
  console.log('再见!');
  process.exit(0);
});
</CODE></PRE>
<H2>例子：逐行地读取文件流<SPAN><A class="mark" id="readline_example_read_file_stream_line_by_line" 
href="http://nodejs.cn/api/readline.html#readline_example_read_file_stream_line_by_line">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/readline.html#readline_example_read_file_stream_line_by_line">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/readline/example_read_file_stream_line_by_line.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<P>例子，从一个文件系统<A 
href="http://nodejs.cn/api/stream.html#stream_readable_streams">可读流</A>中每次一行地消耗输入：</P>
<PRE><CODE class="lang-js">const readline = require('readline');
const fs = require('fs');

const rl = readline.createInterface({
  input: fs.createReadStream('sample.txt')
});

rl.on('line', (line) =&gt; {
  console.log(`文件的单行内容：${line}`);
});
</CODE></PRE></DIV></DIV></DIV><!-- 搜索弹窗 --> 
  
<DIV id="modal_search_bg"></DIV>
<DIV 
id="modal_search"><INPUT id="modal_search_input" placeholder="API 快速搜索" value=""> 
    
<DIV id="modal_search_result"></DIV></DIV><!-- js -->   <!--[if lt IE 10]><script src="/static/lib/placeholders.js?20170426"></script><![endif]--> 
  
<SCRIPT src="readline%20%20Node_js%20API%20文档_files/api.js"></SCRIPT>
 </BODY></HTML>
