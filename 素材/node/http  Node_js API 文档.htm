<!DOCTYPE HTML>
<!-- saved from url=(0030)http://nodejs.cn/api/http.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cmn-Hans"><HEAD><META 
content="IE=11.0000" http-equiv="X-UA-Compatible">
   
<META charset="utf-8">   <TITLE>http | Node.js API 文档</TITLE>   <LINK href="http%20%20Node_js%20API%20文档_files/api.css" 
rel="stylesheet">   <LINK href="/static/favicon.png" rel="icon" type="image/png" 
sizes="32x32"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18639"></HEAD> 
<BODY class="alt apidoc" id="api-section-http">
<DIV class="clearfix" id="content">
<DIV class="interior" id="column2">
<DIV class="interior" id="intro"><A href="http://nodejs.cn/">          Node.js 
中文网         </A>         
<DIV><INPUT id="search_input" placeholder="API 快速搜索" value="">         
</DIV></DIV>
<UL>
  <LI><A class="nav-documentation" href="http://nodejs.cn/api/documentation.html">关于本文档</A></LI>
  <LI><A class="nav-synopsis" 
  href="http://nodejs.cn/api/synopsis.html">用法与例子</A></LI></UL>
<DIV class="line"></DIV>
<UL>
  <LI><A class="nav-assert" href="http://nodejs.cn/api/assert.html">Assert 
  (断言)</A></LI>
  <LI><A class="nav-buffer" 
  href="http://nodejs.cn/api/buffer.html">Buffer</A></LI>
  <LI><A class="nav-addons" href="http://nodejs.cn/api/addons.html">C/C++ 
  插件</A></LI>
  <LI><A class="nav-child_process" href="http://nodejs.cn/api/child_process.html">Child 
  Processes (子进程)</A></LI>
  <LI><A class="nav-cluster" href="http://nodejs.cn/api/cluster.html">Cluster 
  (集群)</A></LI>
  <LI><A class="nav-cli" href="http://nodejs.cn/api/cli.html">CLI 
  (命令行选项)</A></LI>
  <LI><A class="nav-console" href="http://nodejs.cn/api/console.html">Console 
  (控制台)</A></LI>
  <LI><A class="nav-crypto" href="http://nodejs.cn/api/crypto.html">Crypto 
  (加密)</A></LI>
  <LI><A class="nav-debugger" href="http://nodejs.cn/api/debugger.html">Debugger 
  (调试器)</A></LI>
  <LI><A class="nav-dns" href="http://nodejs.cn/api/dns.html">DNS 
  (域名服务器)</A></LI>
  <LI><A class="nav-domain" href="http://nodejs.cn/api/domain.html">Domain 
  (域)</A></LI>
  <LI><A class="nav-errors" href="http://nodejs.cn/api/errors.html">Error 
  (错误)</A></LI>
  <LI><A class="nav-events" href="http://nodejs.cn/api/events.html">Events 
  (事件)</A></LI>
  <LI><A class="nav-fs" href="http://nodejs.cn/api/fs.html">File System 
  (文件系统)</A></LI>
  <LI><A class="nav-globals" href="http://nodejs.cn/api/globals.html">Global 
  (全局变量)</A></LI>
  <LI><A class="nav-http active" 
  href="http://nodejs.cn/api/http.html">HTTP</A></LI>
  <LI><A class="nav-https" href="http://nodejs.cn/api/https.html">HTTPS</A></LI>
  <LI><A class="nav-modules" href="http://nodejs.cn/api/modules.html">Module 
  (模块)</A></LI>
  <LI><A class="nav-net" href="http://nodejs.cn/api/net.html">Net (网络)</A></LI>
  <LI><A class="nav-os" href="http://nodejs.cn/api/os.html">OS (操作系统)</A></LI>
  <LI><A class="nav-path" href="http://nodejs.cn/api/path.html">Path 
  (路径)</A></LI>
  <LI><A class="nav-process" href="http://nodejs.cn/api/process.html">Process 
  (进程)</A></LI>
  <LI><A class="nav-punycode" 
  href="http://nodejs.cn/api/punycode.html">Punycode</A></LI>
  <LI><A class="nav-querystring" 
  href="http://nodejs.cn/api/querystring.html">Query Strings (查询字符串)</A></LI>
  <LI><A class="nav-readline" href="http://nodejs.cn/api/readline.html">Readline 
  (逐行读取)</A></LI>
  <LI><A class="nav-repl" href="http://nodejs.cn/api/repl.html">REPL 
  (交互式解释器)</A></LI>
  <LI><A class="nav-stream" href="http://nodejs.cn/api/stream.html">Stream 
  (流)</A></LI>
  <LI><A class="nav-string_decoder" href="http://nodejs.cn/api/string_decoder.html">String 
  Decoder (字符串解码器)</A></LI>
  <LI><A class="nav-timers" href="http://nodejs.cn/api/timers.html">Timer 
  (定时器)</A></LI>
  <LI><A class="nav-tls" href="http://nodejs.cn/api/tls.html">TLS 
  (安全传输层)</A></LI>
  <LI><A class="nav-tty" href="http://nodejs.cn/api/tty.html">TTY (终端)</A></LI>
  <LI><A class="nav-dgram" href="http://nodejs.cn/api/dgram.html">UDP/Datagram 
  (数据报)</A></LI>
  <LI><A class="nav-url" href="http://nodejs.cn/api/url.html">URL</A></LI>
  <LI><A class="nav-util" href="http://nodejs.cn/api/util.html">Util 
  (实用工具)</A></LI>
  <LI><A class="nav-v8" href="http://nodejs.cn/api/v8.html">V8</A></LI>
  <LI><A class="nav-vm" href="http://nodejs.cn/api/vm.html">VM (虚拟机)</A></LI>
  <LI><A class="nav-zlib" href="http://nodejs.cn/api/zlib.html">ZLIB 
  (压缩)</A></LI></UL>
<DIV class="line"></DIV></DIV>
<DIV class="interior" id="column1" data-id="http"><HEADER>
<H1>Node.js v6.10.3 文档</H1>
<DIV id="gtoc">
<P><A name="toc" href="http://nodejs.cn/api/">返回文档首页</A>             <!--<a href="/api/all.html">单页面显示</a> |--> 
            <!--<a href="/api/http.json">JSON格式</a> |-->             <!--<a href="/api/en/http.html">查看英文版</a>--> 
          </P></DIV>
<HR>
</HEADER>
<DIV id="toc">
<H2>目录</H2>
<UL>
  <LI><SPAN class="stability_2"><A href="http://nodejs.cn/api/http.html#http_http">http</A></SPAN>
  <UL> 
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_class_http_agent">http.Agent 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_new_agent_options">new 
      Agent([options])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_createconnection_options_callback">agent.createConnection(options[, 
      callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_destroy">agent.destroy()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_freesockets">agent.freeSockets</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_getname_options">agent.getName(options)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_maxfreesockets">agent.maxFreeSockets</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_maxsockets">agent.maxSockets</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_requests">agent.requests</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_agent_sockets">agent.sockets</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_class_http_clientrequest">http.ClientRequest 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_abort">'abort' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_aborted">'aborted' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_connect">'connect' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_continue">'continue' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_response">'response' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_socket">'socket' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_upgrade">'upgrade' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_abort">request.abort()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_aborted">request.aborted</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_end_data_encoding_callback">request.end([data][, 
      encoding][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_flushheaders">request.flushHeaders()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_setnodelay_nodelay">request.setNoDelay([noDelay])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_setsocketkeepalive_enable_initialdelay">request.setSocketKeepAlive([enable][, 
      initialDelay])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_settimeout_timeout_callback">request.setTimeout(timeout[, 
      callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_request_write_chunk_encoding_callback">request.write(chunk[, 
      encoding][, callback])</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_class_http_server">http.Server 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_checkcontinue">'checkContinue' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_checkexpectation">'checkExpectation' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_clienterror">'clientError' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_close">'close' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_connect_1">'connect' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_connection">'connection' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_request">'request' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_upgrade_1">'upgrade' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_close_callback">server.close([callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_listen_handle_callback">server.listen(handle[, 
      callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_listen_path_callback">server.listen(path[, 
      callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_listen_port_hostname_backlog_callback">server.listen([port][, 
      hostname][, backlog][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_listening">server.listening</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_maxheaderscount">server.maxHeadersCount</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_settimeout_msecs_callback">server.setTimeout(msecs, 
      callback)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_server_timeout">server.timeout</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">http.ServerResponse 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_close_1">'close' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_finish">'finish' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_addtrailers_headers">response.addTrailers(headers)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback">response.end([data][, 
      encoding][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_finished">response.finished</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_getheader_name">response.getHeader(name)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_headerssent">response.headersSent</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_removeheader_name">response.removeHeader(name)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_senddate">response.sendDate</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_setheader_name_value">response.setHeader(name, 
      value)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_settimeout_msecs_callback">response.setTimeout(msecs, 
      callback)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_statuscode">response.statusCode</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_statusmessage">response.statusMessage</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback">response.write(chunk[, 
      encoding][, callback])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_writecontinue">response.writeContinue()</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers">response.writeHead(statusCode[, 
      statusMessage][, headers])</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">http.IncomingMessage 
    类</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_aborted_1">'aborted' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_event_close_2">'close' 
      事件</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_destroy_error">message.destroy([error])</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_headers">message.headers</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_httpversion">message.httpVersion</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_method">message.method</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_rawheaders">message.rawHeaders</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_rawtrailers">message.rawTrailers</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_settimeout_msecs_callback">message.setTimeout(msecs, 
      callback)</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_statuscode">message.statusCode</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_statusmessage">message.statusMessage</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_socket">message.socket</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_trailers">message.trailers</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_message_url">message.url</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_methods">http.METHODS</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_status_codes">http.STATUS_CODES</A></SPAN></LI>
    <LI><SPAN class="stability_0"><A href="http://nodejs.cn/api/http.html#http_http_createclient_port_host">http.createClient([port][, 
    host])</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_createserver_requestlistener">http.createServer([requestListener])</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_get_options_callback">http.get(options[, 
    callback])</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_globalagent">http.globalAgent</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/http.html#http_http_request_options_callback">http.request(options[, 
    callback])</A></SPAN></LI></UL></LI></UL></DIV>
<DIV id="apicontent">
<H1>http<SPAN><A class="mark" id="http_http" href="http://nodejs.cn/api/http.html#http_http">#</A></SPAN></H1>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_2"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 2</A> - 稳定的</PRE>
<P>要使用 HTTP 服务器与客户端，需要 <CODE>require('http')</CODE>。</P>
<P>Node.js 中的 HTTP 接口被设计成支持协议的多种特性，这些特性以往都较难使用。 比如，大块编码的消息。
 这些接口从不缓存整个请求或响应，用户能够以流的形式处理数据。</P>
<P>HTTP 消息头由一个对象表示，例如：</P>
<PRE><CODE class="lang-js">{ 'content-length': '123',
  'content-type': 'text/plain',
  'connection': 'keep-alive',
  'host': 'mysite.com',
  'accept': '*/*' }
</CODE></PRE>
<P>键名是小写的，键值不能修改。</P>
<P>为了支持各种可能的 HTTP 应用，Node.js 的 HTTP API 是非常底层的。 它只涉及流处理与消息解析。
 它把一个消息解析成消息头和消息主体，但不解析具体的消息头或消息主体。</P>
<P>查看 <A 
href="http://nodejs.cn/api/http.html#http_message_headers"><CODE>message.headers</CODE></A> 
了解如何处理重复的消息头。</P>
<P>接收到的原始消息头保存在 <CODE>rawHeaders</CODE> 属性中，它是一个 <CODE>[key, value, key2, 
value2, ...]</CODE> 数组。 例如，上面的消息头对象可能有一个类似以下的 <CODE>rawHeaders</CODE> 列表：</P>
<PRE><CODE class="lang-js">[ 'ConTent-Length', '123456',
  'content-LENGTH', '123',
  'content-type', 'text/plain',
  'CONNECTION', 'keep-alive',
  'Host', 'mysite.com',
  'accepT', '*/*' ]
</CODE></PRE>
<H2>http.Agent 类<SPAN><A class="mark" id="http_class_http_agent" href="http://nodejs.cn/api/http.html#http_class_http_agent">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_class_http_agent">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/class_http_agent.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.4</SPAN> </DIV>
<P><CODE>Agent</CODE> 负责为 HTTP 客户端管理连接的持续与复用。
 它为一个给定的主机与端口维护着一个等待请求的队列，且为每个请求重复使用一个单一的 socket 连接直到队列为空，此时 socket 
会被销毁或被放入一个连接池中，在连接池中等待被有着相同主机与端口的请求再次使用。 是否被销毁或被放入连接池取决于 <A href="http://nodejs.cn/api/http.html#http_new_agent_options"><CODE>keepAlive</CODE> 
选项</A>。</P>
<P>连接池中的连接的 TCP Keep-Alive 是开启的，但服务器仍然可能关闭闲置的连接，在这种情况下，这些连接会被移出连接池，且当一个新的 HTTP 
请求被创建时再为指定的主机与端口创建一个新的连接。 服务器也可能拒绝允许同一连接上有多个请求，在这种情况下，连接会为每个请求重新创建，且不能被放入连接池。 
<CODE>Agent</CODE> 仍然会创建请求到服务器，但每个请求会出现在一个新的连接。</P>
<P>但一个连接被客户端或服务器关闭时，它会被移出连接池。 连接池中任何未被使用的 socket 会被释放，从而使 Node.js 
进程在没有请求时不用保持运行。 （查看 <A 
href="http://nodejs.cn/api/net.html#net_socket_unref">socket.unref()</A>）。</P>
<P>当 <CODE>Agent</CODE> 实例不再被使用时，建议 <A href="http://nodejs.cn/api/http.html#http_agent_destroy"><CODE>destroy()</CODE></A> 
它，因为未被使用的 socket 也会消耗操作系统资源。</P>
<P>当 socket 触发 <CODE>'close'</CODE> 事件或 <CODE>'agentRemove'</CODE> 事件时，它会被移出代理池。
 这意味着如果你打算长时间保持打开一个 HTTP 请求且不想它留着连接池中，则可以如下处理：</P>
<PRE><CODE class="lang-js">http.get(options, (res) =&gt; {
  // 处理事情
}).on('socket', (socket) =&gt; {
  socket.emit('agentRemove');
});
</CODE></PRE>
<P>你也可以为一个单独的请求使用一个代理。 使用 <CODE>{agent: false}</CODE> 作为 <CODE>http.get()</CODE> 
函数或 <CODE>http.request()</CODE> 函数的选项，则会为客户端连接创建一个默认配置的一次性使用的 
<CODE>Agent</CODE>。</P>
<P><CODE>agent:false</CODE>:</P>
<PRE><CODE class="lang-js">http.get({
  hostname: 'localhost',
  port: 80,
  path: '/',
  agent: false  // 创建一个新的代理，只用于本次请求
}, (res) =&gt; {
  // 对响应进行处理
});
</CODE></PRE>
<H3>new Agent([options])<SPAN><A class="mark" id="http_new_agent_options" href="http://nodejs.cn/api/http.html#http_new_agent_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_new_agent_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/new_agent_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.4</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  代理的配置选项。有以下字段：
  <UL>
    <LI><CODE>keepAlive</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    保持 socket 可用即使没有请求，以便它们可被将来的请求使用而无需重新建立一个 TCP 连接。默认为 
<CODE>false</CODE>。</LI>
    <LI><CODE>keepAliveMsecs</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A> 
    当使用了 <CODE>keepAlive</CODE> 选项时，该选项指定 TCP <CODE>Keep-Alive</CODE> 数据包的 <A 
    href="http://nodejs.cn/api/net.html#net_socket_setkeepalive_enable_initialdelay">初始延迟</A>。
     当 <CODE>keepAlive</CODE> 选项为 <CODE>false</CODE> 或 <CODE>undefined</CODE> 
    时，该选项无效。 默认为 <CODE>1000</CODE>。</LI>
    <LI><CODE>maxSockets</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    每个主机允许的最大 socket 数量。 默认为 <CODE>Infinity</CODE>。</LI>
    <LI><CODE>maxFreeSockets</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    在空闲状态下允许打开的最大 socket 数量。 仅当 <CODE>keepAlive</CODE> 为 <CODE>true</CODE> 时才有效。
     默认为 <CODE>256</CODE>。</LI></UL></LI></UL>
<P><A 
href="http://nodejs.cn/api/http.html#http_http_request_options_callback"><CODE>http.request()</CODE></A> 
使用的默认 <A 
href="http://nodejs.cn/api/http.html#http_http_globalagent"><CODE>http.globalAgent</CODE></A> 
的选项均为各自的默认值。</P>
<P>若要配置其中任何一个，则需要创建自己的 <A href="http://nodejs.cn/api/http.html#http_class_http_agent"><CODE>http.Agent</CODE></A> 
实例。</P>
<PRE><CODE class="lang-js">const http = require('http');
var keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);
</CODE></PRE>
<H3>agent.createConnection(options[, callback])<SPAN><A class="mark" id="http_agent_createconnection_options_callback" 
href="http://nodejs.cn/api/http.html#http_agent_createconnection_options_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_createconnection_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_createconnection_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.4</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  包含连接详情的选项。查看 <A href="http://nodejs.cn/api/net.html#net_net_createconnection_options_connectlistener"><CODE>net.createConnection()</CODE></A> 
  了解选项的格式。</LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  接收被创建的 socket 的回调函数。</LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI></UL>
<P>创建一个用于 HTTP 请求的 socket 或流。</P>
<P>默认情况下，该函数类似于 <A href="http://nodejs.cn/api/net.html#net_net_createconnection_options_connectlistener"><CODE>net.createConnection()</CODE></A>。
 但是如果期望更大的灵活性，自定义的代理可以重写该方法。</P>
<P>socket 或流可以通过以下两种方式获取：从该函数返回，或传入 <CODE>callback</CODE>。</P>
<P><CODE>callback</CODE> 有 <CODE>(err, stream)</CODE> 参数。</P>
<H3>agent.destroy()<SPAN><A class="mark" id="http_agent_destroy" href="http://nodejs.cn/api/http.html#http_agent_destroy">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_destroy">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_destroy.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.4</SPAN> </DIV>
<P>销毁当前正被代理使用的任何 socket。</P>
<P>通常不需要这么做。 但是如果使用的代理启用了 <CODE>keepAlive</CODE>，则当确定它不再被使用时，最好显式地关闭代理。
 否则，在服务器终止它们之前，socket 可能还会长时间保持打开。</P>
<H3>agent.freeSockets<SPAN><A class="mark" id="http_agent_freesockets" href="http://nodejs.cn/api/http.html#http_agent_freesockets">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_freesockets">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_freesockets.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.4</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>返回一个对象，包含当前正在等待被启用了 <CODE>keepAlive</CODE> 的代理使用的 socket 数组。 不要修改该属性。</P>
<H3>agent.getName(options)<SPAN><A class="mark" id="http_agent_getname_options" 
href="http://nodejs.cn/api/http.html#http_agent_getname_options">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_getname_options">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_getname_options.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.4</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  为名称生成程序提供信息的选项。
  <UL>
    <LI><CODE>host</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    请求发送至的服务器的域名或 IP 地址。</LI>
    <LI><CODE>port</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    远程服务器的端口。</LI>
    <LI><CODE>localAddress</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    当发送请求时，为网络连接绑定的本地接口。</LI></UL></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>为请求选项的集合获取一个唯一的名称，用来判断一个连接是否可以被复用。 对于 HTTP 代理，返回 
<CODE>host:port:localAddress</CODE>。 对于 HTTPS 代理，名称会包含 CA、证书、密码、以及其他 HTTPS/TLS 
特有的用于判断 socket 复用性的选项。</P>
<H3>agent.maxFreeSockets<SPAN><A class="mark" id="http_agent_maxfreesockets" 
href="http://nodejs.cn/api/http.html#http_agent_maxfreesockets">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_maxfreesockets">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_maxfreesockets.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.7</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P>默认为 256。 对于已启用 <CODE>keepAlive</CODE> 的代理，该属性可设置要保留的空闲 socket 的最大数量。</P>
<H3>agent.maxSockets<SPAN><A class="mark" id="http_agent_maxsockets" href="http://nodejs.cn/api/http.html#http_agent_maxsockets">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_maxsockets">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_maxsockets.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.6</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P>默认为不限制。 该属性可设置代理为每个来源打开的并发 socket 的最大数量。 来源是一个 <CODE>'host:port'</CODE> 或 
<CODE>'host:port:localAddress'</CODE> 组合。</P>
<H3>agent.requests<SPAN><A class="mark" id="http_agent_requests" href="http://nodejs.cn/api/http.html#http_agent_requests">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_requests">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_requests.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>返回一个对象，包含还未被分配到 socket 的请求队列。 不要修改。</P>
<H3>agent.sockets<SPAN><A class="mark" id="http_agent_sockets" href="http://nodejs.cn/api/http.html#http_agent_sockets">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_agent_sockets">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/agent_sockets.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.6</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>返回一个对象，包含当前正被代理使用的 socket 数组。 不要修改。</P>
<H2>http.ClientRequest 类<SPAN><A class="mark" id="http_class_http_clientrequest" 
href="http://nodejs.cn/api/http.html#http_class_http_clientrequest">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_class_http_clientrequest">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/class_http_clientrequest.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.17</SPAN> </DIV>
<P>该对象在 <A href="http://nodejs.cn/api/http.html#http_http_request_options_callback"><CODE>http.request()</CODE></A> 
内部被创建并返回。 它表示着一个正在处理的请求，其请求头已进入队列。 请求头仍可使用 <CODE>setHeader(name, 
value)</CODE>、<CODE>getHeader(name)</CODE> 和 <CODE>removeHeader(name)</CODE> API 
进行修改。 实际的请求头会与第一个数据块一起发送或当关闭连接时发送。</P>
<P>要获取响应，需为 <A 
href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件添加一个监听器到请求对象上。 当响应头被接收到时，<A href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件会从请求对象上被触发 。 <A 
href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件被执行时带有一个参数，该参数是一个 <A href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage"><CODE>http.IncomingMessage</CODE></A> 
实例。</P>
<P>在 <A 
href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件期间，可以添加监听器到响应对象上，比如监听 <CODE>'data'</CODE> 事件。</P>
<P>如果没有添加 <A 
href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件处理函数，则响应会被整个丢弃。 如果添加了 <A href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件处理函数，则必须消耗完响应对象的数据，可通过调用 <CODE>response.read()</CODE>、或添加一个 
<CODE>'data'</CODE> 事件处理函数、或调用 <CODE>.resume()</CODE> 方法。 数据被消耗完时会触发 
<CODE>'end'</CODE> 事件。 在数据被读取完之前会消耗内存，可能会造成 <CODE>'process out of memory'</CODE> 
错误。</P>
<P>注意：Node.js 不会检查 <CODE>Content-Length</CODE> 与已传输的请求主体的长度是否相等。</P>
<P>该请求实现了 <A href="http://nodejs.cn/api/stream.html#stream_class_stream_writable">可写流</A> 
接口。 它是一个包含以下事件的 <A href="http://nodejs.cn/api/events.html#events_class_eventemitter"><CODE>EventEmitter</CODE></A>：</P>
<H3>'abort' 事件<SPAN><A class="mark" id="http_event_abort" href="http://nodejs.cn/api/http.html#http_event_abort">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_abort">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_abort.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v1.4.1</SPAN> </DIV>
<P>当请求已被客户端终止时触发。 该事件仅在首次调用 <CODE>abort()</CODE> 时触发。</P>
<H3>'aborted' 事件<SPAN><A class="mark" id="http_event_aborted" href="http://nodejs.cn/api/http.html#http_event_aborted">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_aborted">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_aborted.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.8</SPAN> </DIV>
<P>当请求已被服务器终止且网络 socket 已关闭时触发。</P>
<H3>'connect' 事件<SPAN><A class="mark" id="http_event_connect" href="http://nodejs.cn/api/http.html#http_event_connect">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_connect">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_connect.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.0</SPAN> </DIV>
<UL>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A></LI>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI>
  <LI><CODE>head</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI></UL>
<P>每当服务器响应 <CODE>CONNECT</CODE> 请求时触发。 如果该事件未被监听，则接收到 <CODE>CONNECT</CODE> 
方法的客户端会关闭连接。</P>
<P>例子，用一对客户端和服务端来展示如何监听 <CODE>'connect'</CODE> 事件：</P>
<PRE><CODE class="lang-js">const http = require('http');
const net = require('net');
const url = require('url');

// 创建一个 HTTP 代理服务器
var proxy = http.createServer( (req, res) =&gt; {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('okay');
});
proxy.on('connect', (req, cltSocket, head) =&gt; {
  // 连接到一个服务器
  var srvUrl = url.parse(`http://${req.url}`);
  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; {
    cltSocket.write('HTTP/1.1 200 Connection Established\r\n' +
                    'Proxy-agent: Node.js-Proxy\r\n' +
                    '\r\n');
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// 代理服务器正在运行
proxy.listen(1337, '127.0.0.1', () =&gt; {

  // 发送一个请求到代理服务器
  var options = {
    port: 1337,
    hostname: '127.0.0.1',
    method: 'CONNECT',
    path: 'www.google.com:80'
  };

  var req = http.request(options);
  req.end();

  req.on('connect', (res, socket, head) =&gt; {
    console.log('已连接！');

    // 通过代理服务器发送一个请求
    socket.write('GET / HTTP/1.1\r\n' +
                 'Host: www.google.com:80\r\n' +
                 'Connection: close\r\n' +
                 '\r\n');
    socket.on('data', (chunk) =&gt; {
      console.log(chunk.toString());
    });
    socket.on('end', () =&gt; {
      proxy.close();
    });
  });
});
</CODE></PRE>
<H3>'continue' 事件<SPAN><A class="mark" id="http_event_continue" href="http://nodejs.cn/api/http.html#http_event_continue">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_continue">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_continue.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.2</SPAN> </DIV>
<P>当服务器发送了一个 <CODE>100 Continue</CODE> 的 HTTP 响应时触发，通常是因为请求包含 <CODE>Expect: 
100-continue</CODE>。 这是客户端将要发送请求主体的指令。</P>
<H3>'response' 事件<SPAN><A class="mark" id="http_event_response" href="http://nodejs.cn/api/http.html#http_event_response">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_response">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_response.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.0</SPAN> </DIV>
<UL>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A></LI></UL>
<P>当请求的响应被接收到时触发。 该事件只触发一次。</P>
<H3>'socket' 事件<SPAN><A class="mark" id="http_event_socket" href="http://nodejs.cn/api/http.html#http_event_socket">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_socket">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_socket.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.3</SPAN> </DIV>
<UL>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI></UL>
<P>当 socket 被分配到请求后触发。</P>
<H3>'upgrade' 事件<SPAN><A class="mark" id="http_event_upgrade" href="http://nodejs.cn/api/http.html#http_event_upgrade">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_upgrade">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_upgrade.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.94</SPAN> </DIV>
<UL>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A></LI>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI>
  <LI><CODE>head</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI></UL>
<P>每当服务器响应 <CODE>upgrade</CODE> 请求时触发。 如果该事件未被监听，则接收到 <CODE>upgrade</CODE> 
请求头的客户端会关闭连接。</P>
<P>例子，用一对客户端和服务端来展示如何监听 <CODE>'upgrade'</CODE> 事件：</P>
<PRE><CODE class="lang-js">const http = require('http');

// 创建一个 HTTP 服务器
var srv = http.createServer( (req, res) =&gt; {
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('okay');
});
srv.on('upgrade', (req, socket, head) =&gt; {
  socket.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' +
               'Upgrade: WebSocket\r\n' +
               'Connection: Upgrade\r\n' +
               '\r\n');

  socket.pipe(socket);
});

// 服务器正在运行
srv.listen(1337, '127.0.0.1', () =&gt; {

  // 发送一个请求
  var options = {
    port: 1337,
    hostname: '127.0.0.1',
    headers: {
      'Connection': 'Upgrade',
      'Upgrade': 'websocket'
    }
  };

  var req = http.request(options);
  req.end();

  req.on('upgrade', (res, socket, upgradeHead) =&gt; {
    console.log('got upgraded!');
    socket.end();
    process.exit(0);
  });
});
</CODE></PRE>
<H3>request.abort()<SPAN><A class="mark" id="http_request_abort" href="http://nodejs.cn/api/http.html#http_request_abort">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_abort">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_abort.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.8</SPAN> </DIV>
<P>标记请求为终止。 调用该方法将使响应中剩余的数据被丢弃且 socket 被销毁。</P>
<H3>request.aborted<SPAN><A class="mark" id="http_request_aborted" href="http://nodejs.cn/api/http.html#http_request_aborted">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_aborted">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_aborted.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.14</SPAN> </DIV>
<P>如果请求已被终止，则该属性的值为请求被终止的时间，从 <CODE>1 January 1970 00:00:00 UTC</CODE> 
到现在的毫秒数。</P>
<H3>request.end([data][, encoding][, callback])<SPAN><A class="mark" id="http_request_end_data_encoding_callback" 
href="http://nodejs.cn/api/http.html#http_request_end_data_encoding_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_end_data_encoding_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_end_data_encoding_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>data</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
  <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>结束发送请求。 如果部分请求主体还未被发送，则会刷新它们到流中。 如果请求是分块的，则会发送终止字符 
<CODE>'0\r\n\r\n'</CODE>。</P>
<P>如果指定了 <CODE>data</CODE>，则相当于调用 <A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback"><CODE>response.write(data, 
encoding)</CODE></A> 之后再调用 <CODE>request.end(callback)</CODE>。</P>
<P>如果指定了 <CODE>callback</CODE>，则当请求流结束时会被调用。</P>
<H3>request.flushHeaders()<SPAN><A class="mark" id="http_request_flushheaders" 
href="http://nodejs.cn/api/http.html#http_request_flushheaders">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_flushheaders">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_flushheaders.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v1.6.0</SPAN> </DIV>
<P>刷新请求头。</P>
<P>出于效率的考虑，Node.js 通常会缓存请求头直到调用 <CODE>request.end()</CODE> 或写入请求数据的第一块。 Node.js 
会将请求头和数据打包成一个单一的 TCP 数据包。</P>
<P>通常那是你想要的（因为它节省了 TCP 往返），除非第一个数据块很长时间之后才被发送。 
<CODE>request.flushHeaders()</CODE> 可以绕过最优选择并提前开始请求。</P>
<H3>request.setNoDelay([noDelay])<SPAN><A class="mark" id="http_request_setnodelay_nodelay" 
href="http://nodejs.cn/api/http.html#http_request_setnodelay_nodelay">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_setnodelay_nodelay">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_setnodelay_nodelay.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>noDelay</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>一旦 socket 被分配给请求且已连接，<A href="http://nodejs.cn/api/net.html#net_socket_setnodelay_nodelay"><CODE>socket.setNoDelay()</CODE></A> 
会被调用。</P>
<H3>request.setSocketKeepAlive([enable][, initialDelay])<SPAN><A class="mark" 
id="http_request_setsocketkeepalive_enable_initialdelay" href="http://nodejs.cn/api/http.html#http_request_setsocketkeepalive_enable_initialdelay">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_setsocketkeepalive_enable_initialdelay">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_setsocketkeepalive_enable_initialdelay.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>enable</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI>
  <LI><CODE>initialDelay</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P>一旦 socket 被分配给请求且已连接，<A href="http://nodejs.cn/api/net.html#net_socket_setkeepalive_enable_initialdelay"><CODE>socket.setKeepAlive()</CODE></A> 
会被调用。</P>
<H3>request.setTimeout(timeout[, callback])<SPAN><A class="mark" id="http_request_settimeout_timeout_callback" 
href="http://nodejs.cn/api/http.html#http_request_settimeout_timeout_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_settimeout_timeout_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_settimeout_timeout_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
  请求被认为是超时的毫秒数。</LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
  可选的函数，当超时发生时被调用。等同于绑定到 <CODE>timeout</CODE> 事件。</LI></UL>
<P>一旦 socket 被分配给请求且已连接，<A href="http://nodejs.cn/api/net.html#net_socket_settimeout_timeout_callback"><CODE>socket.setTimeout()</CODE></A> 
会被调用。</P>
<P>返回 <CODE>request</CODE>。</P>
<H3>request.write(chunk[, encoding][, callback])<SPAN><A class="mark" id="http_request_write_chunk_encoding_callback" 
href="http://nodejs.cn/api/http.html#http_request_write_chunk_encoding_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_request_write_chunk_encoding_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/request_write_chunk_encoding_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.29</SPAN> </DIV>
<UL>
  <LI><CODE>chunk</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
  <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>发送请求主体的一个数据块。 通过多次调用该方法，用户可以以流的形式将请求主体发送到服务器，在这种情况下，当创建请求时，建议使用 
<CODE>['Transfer-Encoding', 'chunked']</CODE> 请求头。</P>
<P><CODE>encoding</CODE> 参数是可选的，仅当 <CODE>chunk</CODE> 是一个字符串时才有效。默认为 
<CODE>'utf8'</CODE>。</P>
<P><CODE>callback</CODE> 参数是可选的，当数据块被刷新时调用。</P>
<P>返回 <CODE>request</CODE>。</P>
<H2>http.Server 类<SPAN><A class="mark" id="http_class_http_server" href="http://nodejs.cn/api/http.html#http_class_http_server">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_class_http_server">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/class_http_server.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.17</SPAN> </DIV>
<P>该类继承自 <A 
href="http://nodejs.cn/api/net.html#net_class_net_server"><CODE>net.Server</CODE></A>，且具有以下额外的事件：</P>
<H3>'checkContinue' 事件<SPAN><A class="mark" id="http_event_checkcontinue" href="http://nodejs.cn/api/http.html#http_event_checkcontinue">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_checkcontinue">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_checkcontinue.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<UL>
  <LI><CODE>request</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A></LI>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">&lt;http.ServerResponse&gt;</A></LI></UL>
<P>每当接收到一个带有 HTTP <CODE>Expect: 100-continue</CODE> 请求头的请求时触发。
 如果该事件未被监听，则服务器会自动响应 <CODE>100 Continue</CODE>。</P>
<P>处理该事件时，如果客户端应该继续发送请求主体，则调用 <A href="http://nodejs.cn/api/http.html#http_response_writecontinue"><CODE>response.writeContinue()</CODE></A>，否则生成一个适当的 
HTTP 响应（例如 400 错误请求）。</P>
<P>注意，当该事件被触发且处理后，<A 
href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
事件不会被触发。</P>
<H3>'checkExpectation' 事件<SPAN><A class="mark" id="http_event_checkexpectation" 
href="http://nodejs.cn/api/http.html#http_event_checkexpectation">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_checkexpectation">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_checkexpectation.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v5.5.0</SPAN> </DIV>
<UL>
  <LI><CODE>request</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_clientrequest">&lt;http.ClientRequest&gt;</A></LI>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">&lt;http.ServerResponse&gt;</A></LI></UL>
<P>每当接收到一个带有 HTTP <CODE>Expect</CODE> 请求头（值不为 <CODE>100-continue</CODE>）的请求时触发。
 如果该事件未被监听，则服务器会自动响应 <CODE>417 Expectation Failed</CODE>。</P>
<P>注意，当该事件被触发且处理后，<A 
href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
事件不会被触发。</P>
<H3>'clientError' 事件<SPAN><A class="mark" id="http_event_clienterror" href="http://nodejs.cn/api/http.html#http_event_clienterror">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_clienterror">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_clienterror.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.94</SPAN> </DIV>
<UL>
  <LI><CODE>exception</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A></LI>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI></UL>
<P>如果客户端触发了一个 <CODE>'error'</CODE> 事件，则它会被传递到这里。 该事件的监听器负责关闭或销毁底层的 socket。
 例如，用户可能希望更温和地用 HTTP <CODE>'400 Bad Request'</CODE> 响应关闭 socket，而不是突然地切断连接。</P>
<P>默认情况下，请求异常时会立即销毁 socket。</P>
<P><CODE>socket</CODE> 参数是发生错误的 <A href="http://nodejs.cn/api/net.html#net_class_net_socket"><CODE>net.Socket</CODE></A> 
对象。</P>
<PRE><CODE class="lang-js">const http = require('http');

const server = http.createServer((req, res) =&gt; {
  res.end();
});
server.on('clientError', (err, socket) =&gt; {
  socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
});
server.listen(8000);
</CODE></PRE>
<P>当 <CODE>'clientError'</CODE> 事件发生时，不会有 <CODE>request</CODE> 或 
<CODE>response</CODE> 对象，所以发送的任何 HTTP 响应，包括响应头和内容，必须被直接写入到 <CODE>socket</CODE> 
对象。 注意，确保响应是一个被正确格式化的 HTTP 响应消息。</P>
<H3>'close' 事件<SPAN><A class="mark" id="http_event_close" href="http://nodejs.cn/api/http.html#http_event_close">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_close">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_close.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.4</SPAN> </DIV>
<P>当服务器关闭时触发。</P>
<H3>'connect' 事件<SPAN><A class="mark" id="http_event_connect_1" href="http://nodejs.cn/api/http.html#http_event_connect_1">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_connect_1">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_connect_1.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.0</SPAN> </DIV>
<UL>
  <LI><CODE>request</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A> 
  HTTP 请求，同 <A 
  href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
  事件。</LI>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A> 
  服务器与客户端之间的网络 socket。</LI>
  <LI><CODE>head</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
  流的第一个数据包，可能为空。</LI></UL>
<P>每当客户端发送 HTTP <CODE>CONNECT</CODE> 请求时触发。 如果该事件未被监听，则发送 <CODE>CONNECT</CODE> 
请求的客户端会关闭连接。</P>
<P>当该事件被触发后，请求的 socket 上没有 <CODE>'data'</CODE> 事件监听器，这意味着你需要绑定 
<CODE>'data'</CODE> 事件监听器，用来处理 socket 上被发送到服务器的数据。</P>
<H3>'connection' 事件<SPAN><A class="mark" id="http_event_connection" href="http://nodejs.cn/api/http.html#http_event_connection">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_connection">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_connection.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.0</SPAN> </DIV>
<UL>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI></UL>
<P>当一个新的 TCP 流被建立时触发。 <CODE>socket</CODE> 是一个 <A href="http://nodejs.cn/api/net.html#net_class_net_socket"><CODE>net.Socket</CODE></A> 
类型的对象。 通常用户无需访问该事件。 注意，因为协议解析器绑定到 socket 的方式，socket 不会触发 <CODE>'readable'</CODE> 
事件。 <CODE>socket</CODE> 也可以通过 <CODE>request.connection</CODE> 访问。</P>
<H3>'request' 事件<SPAN><A class="mark" id="http_event_request" href="http://nodejs.cn/api/http.html#http_event_request">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_request">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_request.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.0</SPAN> </DIV>
<UL>
  <LI><CODE>request</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A></LI>
  <LI><CODE>response</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">&lt;http.ServerResponse&gt;</A></LI></UL>
<P>每次接收到一个请求时触发。 注意，每个连接可能有多个请求（在 HTTP <CODE>keep-alive</CODE> 连接的情况下）。</P>
<H3>'upgrade' 事件<SPAN><A class="mark" id="http_event_upgrade_1" href="http://nodejs.cn/api/http.html#http_event_upgrade_1">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_upgrade_1">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_upgrade_1.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.94</SPAN> </DIV>
<UL>
  <LI><CODE>request</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">&lt;http.IncomingMessage&gt;</A> 
  HTTP 请求，同 <A 
  href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
  事件。</LI>
  <LI><CODE>socket</CODE> <A class="type" href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A> 
  服务器与客户端之间的网络 socket。</LI>
  <LI><CODE>head</CODE> <A class="type" href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A> 
  流的第一个数据包，可能为空。</LI></UL>
<P>每当客户端发送 HTTP <CODE>upgrade</CODE> 请求时触发。 如果该事件未被监听，则发送 <CODE>upgrade</CODE> 
请求的客户端会关闭连接。</P>
<P>当该事件被触发后，请求的 socket 上没有 <CODE>'data'</CODE> 事件监听器，这意味着你需要绑定 
<CODE>'data'</CODE> 事件监听器，用来处理 socket 上被发送到服务器的数据。</P>
<H3>server.close([callback])<SPAN><A class="mark" id="http_server_close_callback" 
href="http://nodejs.cn/api/http.html#http_server_close_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_close_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_close_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>停止服务端接收新的连接。详见 <A href="http://nodejs.cn/api/net.html#net_server_close_callback"><CODE>net.Server.close()</CODE></A>。</P>
<H3>server.listen(handle[, callback])<SPAN><A class="mark" id="http_server_listen_handle_callback" 
href="http://nodejs.cn/api/http.html#http_server_listen_handle_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_listen_handle_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_listen_handle_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.10</SPAN> </DIV>
<UL>
  <LI><CODE>handle</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P><CODE>handle</CODE> 对象可以被设为一个服务器或 socket、或一个 <CODE>{fd: &lt;n&gt;}</CODE> 
对象。</P>
<P>这会使服务器以指定的句柄接受连接，但假定文件描述符或句柄已经被绑定到了端口或者域 socket。</P>
<P>Windows 平台上不支持监听文件描述符。</P>
<P>该函数是异步的。 <CODE>callback</CODE> 会被添加到 <A href="http://nodejs.cn/api/net.html#net_event_listening"><CODE>'listening'</CODE></A> 
事件的监听器中。详见 <A href="http://nodejs.cn/api/net.html#net_server_listen_handle_backlog_callback"><CODE>net.Server.listen()</CODE></A>。</P>
<P>返回 <CODE>server</CODE>。</P>
<P>注意，<CODE>server.listen()</CODE> 方法可能被多次调用。
 每次调用都会使用提供的选项<STRONG>重新打开</STRONG>服务器。</P>
<H3>server.listen(path[, callback])<SPAN><A class="mark" id="http_server_listen_path_callback" 
href="http://nodejs.cn/api/http.html#http_server_listen_path_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_listen_path_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_listen_path_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>path</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>启动一个 UNIX socket 服务器，并在给定的 <CODE>path</CODE> 上监听连接。</P>
<P>该函数是异步的。 <CODE>callback</CODE> 会被添加到 <A href="http://nodejs.cn/api/net.html#net_event_listening"><CODE>'listening'</CODE></A> 
事件的监听器中。详见 <A href="http://nodejs.cn/api/net.html#net_server_listen_path_backlog_callback"><CODE>net.Server.listen(path)</CODE></A>。</P>
<P>注意，<CODE>server.listen()</CODE> 方法可能被多次调用。
 每次调用都会使用提供的选项<STRONG>重新打开</STRONG>服务器。</P>
<H3>server.listen([port][, hostname][, backlog][, callback])<SPAN><A class="mark" 
id="http_server_listen_port_hostname_backlog_callback" href="http://nodejs.cn/api/http.html#http_server_listen_port_hostname_backlog_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_listen_port_hostname_backlog_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_listen_port_hostname_backlog_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>port</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>hostname</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>backlog</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>开始在指定的 <CODE>port</CODE> 和 <CODE>hostname</CODE> 上接受连接。 如果省略了 
<CODE>hostname</CODE>，则当 IPv6 可用时，服务器会接受任何 IPv6 地址（<CODE>::</CODE>）的连接，否则接受任何 
IPv4 地址（<CODE>0.0.0.0</CODE>）的连接。 省略 <CODE>port</CODE> 参数或使用端口值 
<CODE>0</CODE>，则操作系统会分配一个随机的端口，该端口可在 <CODE>'listening'</CODE> 事件已被触发后通过使用 
<CODE>server.address().port</CODE> 获取。</P>
<P>要监听一个 UNIX socket，需要提供文件名而不是端口和主机名。</P>
<P><CODE>backlog</CODE> 是等待连接的队列的最大长度。 实际长度由操作系统通过 sysctl 设置决定，比如 Linux 上的 
<CODE>tcp_max_syn_backlog</CODE> 和 <CODE>somaxconn</CODE>。 该参数的默认值是 511（不是 
512）。</P>
<P>该函数是异步的。 <CODE>callback</CODE> 会被添加到 <A href="http://nodejs.cn/api/net.html#net_event_listening"><CODE>'listening'</CODE></A> 
事件的监听器中。详见 <A href="http://nodejs.cn/api/net.html#net_server_listen_port_hostname_backlog_callback"><CODE>net.Server.listen(port)</CODE></A>。</P>
<P>注意，<CODE>server.listen()</CODE> 方法可能被多次调用。
 每次调用都会使用提供的选项<STRONG>重新打开</STRONG>服务器。</P>
<H3>server.listening<SPAN><A class="mark" id="http_server_listening" href="http://nodejs.cn/api/http.html#http_server_listening">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_listening">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_listening.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v5.7.0</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>一个表明服务器是否正在监听连接的布尔值。</P>
<H3>server.maxHeadersCount<SPAN><A class="mark" id="http_server_maxheaderscount" 
href="http://nodejs.cn/api/http.html#http_server_maxheaderscount">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_maxheaderscount">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_maxheaderscount.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.0</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P>限制最大的请求头数量, 默认为 1000。 如果设为 0，则不做任何限制。</P>
<H3>server.setTimeout(msecs, callback)<SPAN><A class="mark" id="http_server_settimeout_msecs_callback" 
href="http://nodejs.cn/api/http.html#http_server_settimeout_msecs_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_settimeout_msecs_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_settimeout_msecs_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.9.12</SPAN> </DIV>
<UL>
  <LI><CODE>msecs</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>为 socket 设置超时值。 如果一个超时发生，则 Server 对象上会触发一个 <CODE>'timeout'</CODE> 事件，并传入该 
socket 作为一个参数。</P>
<P>如果 Server 对象上有 <CODE>'timeout'</CODE> 事件监听器，则它会被调用，并带上超时的 socket 作为一个参数。</P>
<P>默认情况下，服务器的超时时间是 2 分钟，且超时后的 socket 会被自动销毁。 但是，如果你为服务器的 <CODE>'timeout'</CODE> 
事件分配了一个回调函数，则你需要负责处理 socket 的超时。</P>
<P>返回 <CODE>server</CODE>。</P>
<H3>server.timeout<SPAN><A class="mark" id="http_server_timeout" href="http://nodejs.cn/api/http.html#http_server_timeout">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_server_timeout">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/server_timeout.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.9.12</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
  默认 = 120000 (2 分钟)</LI></UL>
<P>一个 socket 被认定为已超时的空闲毫秒数。</P>
<P>注意，socket 
的超时逻辑是在连接上设定的，所以更改这个值只影响服务器<STRONG>新建</STRONG>的连接，而不会影响任何已存在的连接。</P>
<P>设为 0 可禁用请求连接的一切自动超时行为。</P>
<H2>http.ServerResponse 类<SPAN><A class="mark" id="http_class_http_serverresponse" 
href="http://nodejs.cn/api/http.html#http_class_http_serverresponse">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_class_http_serverresponse">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/class_http_serverresponse.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.17</SPAN> </DIV>
<P>该对象是由一个 HTTP 服务器（而不是用户）内部创建的。 它作为第二个参数被传入 <A href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
事件。</P>
<P>该响应实现（而不是继承自）<A href="http://nodejs.cn/api/stream.html#stream_class_stream_writable">可写流</A>接口。
 这是一个有以下事件的 <A 
href="http://nodejs.cn/api/events.html#events_class_eventemitter"><CODE>EventEmitter</CODE></A>：</P>
<H3>'close' 事件<SPAN><A class="mark" id="http_event_close_1" href="http://nodejs.cn/api/http.html#http_event_close_1">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_close_1">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_close_1.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.6.7</SPAN> </DIV>
<P>表明在 <A href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback"><CODE>response.end()</CODE></A> 
被调用或能够刷新之前，底层连接被终止了。</P>
<H3>'finish' 事件<SPAN><A class="mark" id="http_event_finish" href="http://nodejs.cn/api/http.html#http_event_finish">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_finish">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_finish.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.6</SPAN> </DIV>
<P>当响应已被发送时触发。 更具体地说，当响应头和主体的最后一部分已被交给操作系统通过网络进行传输时，触发该事件。
 这并不意味着客户端已接收到任何东西。</P>
<P>该事件触发后，响应对象上不再触发其他事件。</P>
<H3>response.addTrailers(headers)<SPAN><A class="mark" id="http_response_addtrailers_headers" 
href="http://nodejs.cn/api/http.html#http_response_addtrailers_headers">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_addtrailers_headers">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_addtrailers_headers.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<UL>
  <LI><CODE>headers</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>该方法会给响应添加 HTTP 追踪请求头（一个在消息尾部的请求头）。</P>
<P>追踪<STRONG>仅</STRONG>当响应使用分块编码时才会被发送；如果不是（比如请求是 HTTP/1.0），则它们将被丢弃。</P>
<P>注意，如果想要发送追踪，则 HTTP 要求发送 <CODE>Trailer</CODE> 请求头，且在值里带上请求头字段的列表。 例如：</P>
<PRE><CODE class="lang-js">response.writeHead(200, { 'Content-Type': 'text/plain',
                          'Trailer': 'Content-MD5' });
response.write(fileData);
response.addTrailers({'Content-MD5': '7895bf4b8828b55ceaf47747b4bca667'});
response.end();
</CODE></PRE>
<P>试图设置一个包含无效字符的请求头字段名称或值会导致抛出一个 <A href="http://nodejs.cn/api/errors.html#errors_class_typeerror"><CODE>TypeError</CODE></A>。</P>
<H3>response.end([data][, encoding][, callback])<SPAN><A class="mark" id="http_response_end_data_encoding_callback" 
href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_end_data_encoding_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_end_data_encoding_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><CODE>data</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
  <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>该方法告诉服务器所有响应头和主体都已被发送；服务器应将消息视为已完成。 对于每个响应，<CODE>response.end()</CODE> 
方法<STRONG>必须</STRONG>被调用。</P>
<P>如果指定了 <CODE>data</CODE>，则它等同于调用 <A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback"><CODE>response.write(data, 
encoding)</CODE></A> 之后调用 <CODE>response.end(callback)</CODE>。</P>
<P>如果指定了 <CODE>callback</CODE>，则当响应流结束时被调用。</P>
<H3>response.finished<SPAN><A class="mark" id="http_response_finished" href="http://nodejs.cn/api/http.html#http_response_finished">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_finished">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_finished.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.0.2</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>布尔值，表明响应是否已完成。 开始时为 <CODE>false</CODE>。 执行 <A href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback"><CODE>response.end()</CODE></A> 
后，该值会变为 <CODE>true</CODE>。</P>
<H3>response.getHeader(name)<SPAN><A class="mark" id="http_response_getheader_name" 
href="http://nodejs.cn/api/http.html#http_response_getheader_name">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_getheader_name">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_getheader_name.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.4.0</SPAN> </DIV>
<UL>
  <LI><CODE>name</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>读出已经排队但尚未发送到客户端的消息头。 注意，名称不区分大小写。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">var contentType = response.getHeader('content-type');
</CODE></PRE>
<H3>response.headersSent<SPAN><A class="mark" id="http_response_headerssent" 
href="http://nodejs.cn/api/http.html#http_response_headerssent">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_headerssent">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_headerssent.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.9.3</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>布尔值（只读）。 如果消息头已被发送则为 <CODE>true</CODE>，否则为 <CODE>false</CODE>。</P>
<H3>response.removeHeader(name)<SPAN><A class="mark" id="http_response_removeheader_name" 
href="http://nodejs.cn/api/http.html#http_response_removeheader_name">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_removeheader_name">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_removeheader_name.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.4.0</SPAN> </DIV>
<UL>
  <LI><CODE>name</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>从隐式发送的队列中移除一个消息头。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">response.removeHeader('Content-Encoding');
</CODE></PRE>
<H3>response.sendDate<SPAN><A class="mark" id="http_response_senddate" href="http://nodejs.cn/api/http.html#http_response_senddate">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_senddate">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_senddate.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.7.5</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>当为 <CODE>true</CODE> 时，如果消息头里还不存在日期消息头，则它会被自动生成并在响应中发送。默认为 
<CODE>true</CODE>。</P>
<P>这应该只在测试中才被禁用；HTTP 需要响应日期消息头。</P>
<H3>response.setHeader(name, value)<SPAN><A class="mark" id="http_response_setheader_name_value" 
href="http://nodejs.cn/api/http.html#http_response_setheader_name_value">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_setheader_name_value">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_setheader_name_value.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.4.0</SPAN> </DIV>
<UL>
  <LI><CODE>name</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>value</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>为隐式消息头集合设置一个的消息头值。 如果该消息头已经存在将要发送的消息头集合中，则该值会被覆盖。
 如果需要发送多个名称相同的消息头，则使用一个字符串数组。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">response.setHeader('Content-Type', 'text/html');
</CODE></PRE>
<P>或</P>
<PRE><CODE class="lang-js">response.setHeader('Set-Cookie', ['type=ninja', 'language=javascript']);
</CODE></PRE>
<P>试图设置一个包含无效字符的消息头字段名称或值会导致抛出一个 <A href="http://nodejs.cn/api/errors.html#errors_class_typeerror"><CODE>TypeError</CODE></A>。</P>
<P>当消息头已使用 <A href="http://nodejs.cn/api/http.html#http_response_setheader_name_value"><CODE>response.setHeader()</CODE></A> 
设置，它们会被与其他消息头合并传给 <A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A>，带消息头的 
<A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A> 
有更高优先级。</P>
<PRE><CODE class="lang-js">// 返回 content-type = text/plain
const server = http.createServer((req,res) =&gt; {
  res.setHeader('Content-Type', 'text/html');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('ok');
});
</CODE></PRE>
<H3>response.setTimeout(msecs, callback)<SPAN><A class="mark" id="http_response_settimeout_msecs_callback" 
href="http://nodejs.cn/api/http.html#http_response_settimeout_msecs_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_settimeout_msecs_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_settimeout_msecs_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.9.12</SPAN> </DIV>
<UL>
  <LI><CODE>msecs</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>设置 socket 的超时时间为 <CODE>msecs</CODE>。 如果提供了回调函数，则它会被作为监听器添加到响应对象的 
<CODE>'timeout'</CODE> 事件。</P>
<P>如果没有 <CODE>'timeout'</CODE> 监听器被添加到请求、响应或服务器，则 socket 会在超时后被销毁。 如果在请求、响应或服务器的 
<CODE>'timeout'</CODE> 事件上分配了句柄，则需要负责处理超时的 socket。</P>
<P>返回 <CODE>response</CODE>。</P>
<H3>response.statusCode<SPAN><A class="mark" id="http_response_statuscode" href="http://nodejs.cn/api/http.html#http_response_statuscode">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_statuscode">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_statuscode.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.4.0</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P>当使用隐式的消息头时（没有显式地调用 <A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A>），在消息头被刷新时该属性会控制将被发送到客户端的状态码。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">response.statusCode = 404;
</CODE></PRE>
<P>响应头被发送到客户端后，该属性表明被发出的状态码。</P>
<H3>response.statusMessage<SPAN><A class="mark" id="http_response_statusmessage" 
href="http://nodejs.cn/api/http.html#http_response_statusmessage">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_statusmessage">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_statusmessage.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.8</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>当使用隐式的消息头时（没有显式地调用 <A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A>），在消息头被刷新时该属性会控制将被发送到客户端的状态信息。
 如果该值为 <CODE>undefined</CODE>，则使用状态码的标准信息。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">response.statusMessage = 'Not found';
</CODE></PRE>
<P>响应头被发送到客户端后，该属性表明被发出的状态信息。</P>
<H3>response.write(chunk[, encoding][, callback])<SPAN><A class="mark" id="http_response_write_chunk_encoding_callback" 
href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_write_chunk_encoding_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_write_chunk_encoding_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.29</SPAN> </DIV>
<UL>
  <LI><CODE>chunk</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
  | <A class="type" 
  href="http://nodejs.cn/api/buffer.html#buffer_class_buffer">&lt;Buffer&gt;</A></LI>
  <LI><CODE>encoding</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>如果该方法被调用且 <A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A> 
还未被调用，则它会切换到隐式消息头模式并刷新隐式消息头。</P>
<P>它会发送一块响应主体。 该方法可被多次调用，以便提供主体连续的部分。</P>
<P><CODE>chunk</CODE> 可以是一个字符串或一个 buffer。 如果 <CODE>chunk</CODE> 
是一个字符串，则第二个参数指定如何将它编码成一个字节流。 <CODE>encoding</CODE> 默认为 <CODE>'utf8'</CODE>。
 当数据块被刷新时，<CODE>callback</CODE> 会被调用。</P>
<P><STRONG>注意</STRONG>：这是原始的 HTTP 主体，且与可能使用的更高级别的多部分主体编码无关。</P>
<P><A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback"><CODE>response.write()</CODE></A> 
首次被调用时，它会发送缓冲的头信息和第一块主体到客户端。 <A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback"><CODE>response.write()</CODE></A> 
第二次被调用时，Node.js 会假定你要流化数据，并将它们分别发送。 响应会被缓冲到主体的第一个数据块。</P>
<P>如果整个数据被成功刷新到内核缓冲区，则返回 <CODE>true</CODE>。 如果全部或部分数据在用户内存中排队，则返回 
<CODE>false</CODE>。 当缓冲区再次空闲时，则触发 <CODE>'drain'</CODE> 事件。</P>
<H3>response.writeContinue()<SPAN><A class="mark" id="http_response_writecontinue" 
href="http://nodejs.cn/api/http.html#http_response_writecontinue">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_writecontinue">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_writecontinue.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<P>发送一个 HTTP/1.1 100 Continue 消息到客户端，表明请求主体应该被发送。详见 <CODE>Server</CODE> 的 <A 
href="http://nodejs.cn/api/http.html#http_event_checkcontinue"><CODE>'checkContinue'</CODE></A> 
事件。</P>
<H3>response.writeHead(statusCode[, statusMessage][, headers])<SPAN><A class="mark" 
id="http_response_writehead_statuscode_statusmessage_headers" href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_response_writehead_statuscode_statusmessage_headers">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/response_writehead_statuscode_statusmessage_headers.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.30</SPAN> </DIV>
<UL>
  <LI><CODE>statusCode</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>statusMessage</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI><CODE>headers</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>发送一个响应头给请求。 状态码是一个 3 个数字的 HTTP 状态代码，如 <CODE>404</CODE>。 最后一个参数 
<CODE>headers</CODE> 是响应头。 第二个参数 <CODE>statusMessage</CODE> 是可选的。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">var body = 'hello world';
response.writeHead(200, {
  'Content-Length': Buffer.byteLength(body),
  'Content-Type': 'text/plain' });
</CODE></PRE>
<P>该方法在消息中只能被调用一次，且必须在 <A href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback"><CODE>response.end()</CODE></A> 
被调用之前调用。</P>
<P>如果在调用该方法之前调用 <A href="http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback"><CODE>response.write()</CODE></A> 
或 <A href="http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback"><CODE>response.end()</CODE></A>，则隐式或可变的消息头会被计算并调用该函数。</P>
<P>当消息头已使用 <A href="http://nodejs.cn/api/http.html#http_response_setheader_name_value"><CODE>response.setHeader()</CODE></A> 
设置，它们会被与其他消息头合并传给 <A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A>，带消息头的 
<A href="http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers"><CODE>response.writeHead()</CODE></A> 
有更高优先级。</P>
<PRE><CODE class="lang-js">// 返回 content-type = text/plain
const server = http.createServer((req,res) =&gt; {
  res.setHeader('Content-Type', 'text/html');
  res.setHeader('X-Foo', 'bar');
  res.writeHead(200, {'Content-Type': 'text/plain'});
  res.end('ok');
});
</CODE></PRE>
<P>注意，<CODE>Content-Length</CODE> 是以字节（而不是字符）为单位给出的。 以上的例子有效是因为字符串 <CODE>'hello 
world'</CODE> 仅包含单字节字符。 如果主体包含更高编码的字符，则 <CODE>Buffer.byteLength()</CODE> 
应被用来确定在给定编码中的字节数。 Node.js 不会检查 <CODE>Content-Length</CODE> 与已发送的主体长度是否相同。</P>
<P>试图设置一个包含无效字符的消息头字段名称或值会导致抛出一个 <A href="http://nodejs.cn/api/errors.html#errors_class_typeerror"><CODE>TypeError</CODE></A>。</P>
<H2>http.IncomingMessage 类<SPAN><A class="mark" id="http_class_http_incomingmessage" 
href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_class_http_incomingmessage">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/class_http_incomingmessage.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.17</SPAN> </DIV>
<P><CODE>IncomingMessage</CODE> 对象由 <A href="http://nodejs.cn/api/http.html#http_class_http_server"><CODE>http.Server</CODE></A> 
或 <A 
href="http://nodejs.cn/api/http.html#http_class_http_clientrequest"><CODE>http.ClientRequest</CODE></A> 
创建，并作为第一个参数分别递给 <A 
href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
和 <A 
href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件。 它可以用来访问响应状态、消息头、以及数据。</P>
<P>它实现了<A 
href="http://nodejs.cn/api/stream.html#stream_class_stream_readable">可读流</A>接口，还有以下额外的事件、方法、以及属性。</P>
<H3>'aborted' 事件<SPAN><A class="mark" id="http_event_aborted_1" href="http://nodejs.cn/api/http.html#http_event_aborted_1">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_aborted_1">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_aborted_1.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.8</SPAN> </DIV>
<P>当请求已被客户端终止且网络 socket 已关闭时触发。</P>
<H3>'close' 事件<SPAN><A class="mark" id="http_event_close_2" href="http://nodejs.cn/api/http.html#http_event_close_2">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_event_close_2">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/event_close_2.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.4.2</SPAN> </DIV>
<P>表明底层连接被关闭。 就像 <CODE>'end'</CODE>，该事件每次响应只发生一次。</P>
<H3>message.destroy([error])<SPAN><A class="mark" id="http_message_destroy_error" 
href="http://nodejs.cn/api/http.html#http_message_destroy_error">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_destroy_error">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_destroy_error.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<UL>
  <LI><CODE>error</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error">&lt;Error&gt;</A></LI></UL>
<P>调用接收 <CODE>IncomingMessage</CODE> 的 socket 的 <CODE>destroy()</CODE>。 如果提供了 
<CODE>error</CODE>，则触发 <CODE>'error'</CODE> 事件，且把 <CODE>error</CODE> 
作为一个参数传入事件的任何监听器。</P>
<H3>message.headers<SPAN><A class="mark" id="http_message_headers" href="http://nodejs.cn/api/http.html#http_message_headers">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_headers">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_headers.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.5</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>请求/响应头的对象。</P>
<P>报头名称和值的键值对。 报头名称为小写。 例如：</P>
<PRE><CODE class="lang-js">// 输出类似以下的东西：
//
// { 'user-agent': 'curl/7.22.0',
//   host: '127.0.0.1:8000',
//   accept: '*/*' }
console.log(request.headers);
</CODE></PRE>
<P>原始报头中的重复数据会按以下方式根据报头名称进行处理：</P>
<UL>
  <LI>重复的 <CODE>age</CODE> 、 <CODE>authorization</CODE> 、 
  <CODE>content-length</CODE> 、 <CODE>content-type</CODE> 、  <CODE>etag</CODE> 、 
  <CODE>expires</CODE> 、 <CODE>from</CODE> 、 <CODE>host</CODE> 、 
  <CODE>if-modified-since</CODE> 、 <CODE>if-unmodified-since</CODE> 、  
  <CODE>last-modified</CODE> 、 <CODE>location</CODE> 、 <CODE>max-forwards</CODE> 
  、 <CODE>proxy-authorization</CODE> 、 <CODE>referer</CODE> 、  
  <CODE>retry-after</CODE> 、或 <CODE>user-agent</CODE> 会被丢弃。</LI>
  <LI><CODE>set-cookie</CODE> 始终是一个数组。重复的会被添加到数组。</LI>
  <LI>对于所有的其他报头，其值使用 ', ' 连接。</LI></UL>
<H3>message.httpVersion<SPAN><A class="mark" id="http_message_httpversion" href="http://nodejs.cn/api/http.html#http_message_httpversion">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_httpversion">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_httpversion.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.1</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>当服务器请求时，HTTP 版本由客户端发送。 当客户端响应时，HTTP 版本由所连接的服务器发送。 可能的值有 <CODE>'1.1'</CODE> 或 
<CODE>'1.0'</CODE>。</P>
<P><CODE>message.httpVersionMajor</CODE> 
是第一个整数，<CODE>message.httpVersionMinor</CODE> 是第二个整数。</P>
<H3>message.method<SPAN><A class="mark" id="http_message_method" href="http://nodejs.cn/api/http.html#http_message_method">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_method">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_method.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.1</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P><STRONG>仅适用于从 <A 
href="http://nodejs.cn/api/http.html#http_class_http_server"><CODE>http.Server</CODE></A> 
获得的请求。</STRONG></P>
<P>请求方法是一个字符串。 只读。 例如：<CODE>'GET'</CODE>、<CODE>'DELETE'</CODE>。</P>
<H3>message.rawHeaders<SPAN><A class="mark" id="http_message_rawheaders" href="http://nodejs.cn/api/http.html#http_message_rawheaders">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_rawheaders">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_rawheaders.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.6</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL>
<P>接收到的原始请求/响应头列表。</P>
<P>注意，键和值是在同一列表中。 它<STRONG>不是</STRONG>一个元组列表。 所以，偶数偏移量为键，奇数偏移量为对应的值。</P>
<P>报头名称没有转换为小写，也没有合并去重。</P>
<PRE><CODE class="lang-js">// 输出类似以下的东西：
//
// [ 'user-agent',
//   'this is invalid because there can be only one',
//   'User-Agent',
//   'curl/7.22.0',
//   'Host',
//   '127.0.0.1:8000',
//   'ACCEPT',
//   '*/*' ]
console.log(request.rawHeaders);
</CODE></PRE>
<H3>message.rawTrailers<SPAN><A class="mark" id="http_message_rawtrailers" href="http://nodejs.cn/api/http.html#http_message_rawtrailers">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_rawtrailers">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_rawtrailers.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.6</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL>
<P>接收到的原始的请求/响应报尾的键和值。 只在 <CODE>'end'</CODE> 事件时填入。</P>
<H3>message.setTimeout(msecs, callback)<SPAN><A class="mark" id="http_message_settimeout_msecs_callback" 
href="http://nodejs.cn/api/http.html#http_message_settimeout_msecs_callback">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_settimeout_msecs_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_settimeout_msecs_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><CODE>msecs</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI></UL>
<P>调用 <CODE>message.connection.setTimeout(msecs, callback)</CODE>。</P>
<P>返回 <CODE>message</CODE>。</P>
<H3>message.statusCode<SPAN><A class="mark" id="http_message_statuscode" href="http://nodejs.cn/api/http.html#http_message_statuscode">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_statuscode">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_statuscode.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.1</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A></LI></UL>
<P><STRONG>仅适用于从 <A href="http://nodejs.cn/api/http.html#http_class_http_clientrequest"><CODE>http.ClientRequest</CODE></A> 
获得的响应。</STRONG></P>
<P>3 位数字的 HTTP 响应状态码。 如 <CODE>404</CODE>。</P>
<H3>message.statusMessage<SPAN><A class="mark" id="http_message_statusmessage" 
href="http://nodejs.cn/api/http.html#http_message_statusmessage">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_statusmessage">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_statusmessage.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.10</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P><STRONG>仅适用于从 <A href="http://nodejs.cn/api/http.html#http_class_http_clientrequest"><CODE>http.ClientRequest</CODE></A> 
获得的响应。</STRONG></P>
<P>HTTP 响应状态消息（原因描述）。如 <CODE>OK</CODE> 或 <CODE>Internal Server Error</CODE>。</P>
<H3>message.socket<SPAN><A class="mark" id="http_message_socket" href="http://nodejs.cn/api/http.html#http_message_socket">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_socket">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_socket.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<UL>
  <LI><A class="type" 
  href="http://nodejs.cn/api/net.html#net_class_net_socket">&lt;net.Socket&gt;</A></LI></UL>
<P>与连接有关的 <A 
href="http://nodejs.cn/api/net.html#net_class_net_socket"><CODE>net.Socket</CODE></A> 
对象。</P>
<P>通过 HTTPS 的支持，使用 <A href="http://nodejs.cn/api/tls.html#tls_tlssocket_getpeercertificate_detailed"><CODE>request.socket.getPeerCertificate()</CODE></A> 
获取客户端的认证信息。</P>
<H3>message.trailers<SPAN><A class="mark" id="http_message_trailers" href="http://nodejs.cn/api/http.html#http_message_trailers">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_trailers">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_trailers.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.0</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>请求/响应报尾对象。 只在 <CODE>'end'</CODE> 事件时填入。</P>
<H3>message.url<SPAN><A class="mark" id="http_message_url" href="http://nodejs.cn/api/http.html#http_message_url">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_message_url">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/message_url.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.90</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P><STRONG>仅适用于从 <A 
href="http://nodejs.cn/api/http.html#http_class_http_server"><CODE>http.Server</CODE></A> 
获得的请求。</STRONG></P>
<P>请求的 URL 字符串。 仅包含 HTTP 请求实际存在的 URL。 如果请求是：</P>
<PRE><CODE class="lang-txt">GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n
</CODE></PRE>
<P>则 <CODE>request.url</CODE> 会是：</P>
<PRE><CODE class="lang-js">'/status?name=ryan'
</CODE></PRE>
<P>如果想将 URL 解析成各个部分，可以使用 <CODE>require('url').parse(request.url)</CODE>。 例子：</P>
<PRE><CODE class="lang-txt">$ node
&gt; require('url').parse('/status?name=ryan')
{
  href: '/status?name=ryan',
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status'
}
</CODE></PRE>
<P>如果想从查询字符串中提取参数，可以使用 <CODE>require('querystring').parse</CODE> 函数，或传入 
<CODE>true</CODE> 作为 <CODE>require('url').parse</CODE> 的第二个参数。 例子：</P>
<PRE><CODE class="lang-txt">$ node
&gt; require('url').parse('/status?name=ryan', true)
{
  href: '/status?name=ryan',
  search: '?name=ryan',
  query: {name: 'ryan'},
  pathname: '/status'
}
</CODE></PRE>
<H2>http.METHODS<SPAN><A class="mark" id="http_http_methods" href="http://nodejs.cn/api/http.html#http_http_methods">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_methods">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_methods.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.11.8</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL>
<P>解析器支持的 HTTP 方法列表。</P>
<H2>http.STATUS_CODES<SPAN><A class="mark" id="http_http_status_codes" href="http://nodejs.cn/api/http.html#http_http_status_codes">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_status_codes">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_status_codes.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.22</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>所有的标准 HTTP 响应状态码的集合，以及各自的简短描述。 例如，<CODE>http.STATUS_CODES[404] === 'Not 
Found'</CODE>。</P>
<H2>http.createClient([port][, host])<SPAN><A class="mark" id="http_http_createclient_port_host" 
href="http://nodejs.cn/api/http.html#http_http_createclient_port_host">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_createclient_port_host">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_createclient_port_host.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.13</SPAN> <SPAN>废弃于: v0.3.6 </SPAN> 
</DIV>
<PRE class="api_stability api_stability_0"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 0</A> - 废弃的: 使用 <A href="http://nodejs.cn/api/http.html#http_http_request_options_callback"><CODE>http.request()</CODE></A> 代替。</PRE>
<P>Constructs a new HTTP client. <CODE>port</CODE> and <CODE>host</CODE> refer 
to the server to be connected to.</P>
<H2>http.createServer([requestListener])<SPAN><A class="mark" id="http_http_createserver_requestlistener" 
href="http://nodejs.cn/api/http.html#http_http_createserver_requestlistener">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_createserver_requestlistener">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_createserver_requestlistener.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.13</SPAN> </DIV>
<UL>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_server">&lt;http.Server&gt;</A></LI></UL>
<P>返回一个新建的 <A 
href="http://nodejs.cn/api/http.html#http_class_http_server"><CODE>http.Server</CODE></A> 
实例。</P>
<P><CODE>requestListener</CODE> 是一个会被自动添加到 <A href="http://nodejs.cn/api/http.html#http_event_request"><CODE>'request'</CODE></A> 
事件中的函数。</P>
<H2>http.get(options[, callback])<SPAN><A class="mark" id="http_http_get_options_callback" 
href="http://nodejs.cn/api/http.html#http_http_get_options_callback">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_get_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_get_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.6</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_clientrequest">&lt;http.ClientRequest&gt;</A></LI></UL>
<P>因为大多数请求都是 GET 请求且不带主体，所以 Node.js 提供了这个便捷的方法。 该方法与 <A href="http://nodejs.cn/api/http.html#http_http_request_options_callback"><CODE>http.request()</CODE></A> 
唯一的区别是它设置请求方法为 GET 且自动调用 <CODE>req.end()</CODE>。 注意，响应数据必须在回调中被消耗，原因详见 <A href="http://nodejs.cn/api/http.html#http_class_http_clientrequest"><CODE>http.ClientRequest</CODE></A> 
章节。</P>
<P><CODE>callback</CODE> 被调用时只有一个参数，它是 <A href="http://nodejs.cn/api/http.html#http_class_http_incomingmessage"><CODE>http.IncomingMessage</CODE></A> 
的一个实例。</P>
<P>一个获取 JSON 的例子：</P>
<PRE><CODE class="lang-js">http.get('http://nodejs.org/dist/index.json', (res) =&gt; {
  const statusCode = res.statusCode;
  const contentType = res.headers['content-type'];

  let error;
  if (statusCode !== 200) {
    error = new Error(`请求失败。\n` +
                      `状态码: ${statusCode}`);
  } else if (!/^application\/json/.test(contentType)) {
    error = new Error(`无效的 content-type.\n` +
                      `期望 application/json 但获取的是 ${contentType}`);
  }
  if (error) {
    console.log(error.message);
    // 消耗响应数据以释放内存
    res.resume();
    return;
  }

  res.setEncoding('utf8');
  let rawData = '';
  res.on('data', (chunk) =&gt; rawData += chunk);
  res.on('end', () =&gt; {
    try {
      let parsedData = JSON.parse(rawData);
      console.log(parsedData);
    } catch (e) {
      console.log(e.message);
    }
  });
}).on('error', (e) =&gt; {
  console.log(`错误: ${e.message}`);
});
</CODE></PRE>
<H2>http.globalAgent<SPAN><A class="mark" id="http_http_globalagent" href="http://nodejs.cn/api/http.html#http_http_globalagent">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_globalagent">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_globalagent.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.9</SPAN> </DIV>
<UL>
  <LI><A class="type" href="http://nodejs.cn/api/http.html#http_class_http_agent">&lt;http.Agent&gt;</A></LI></UL>
<P><CODE>Agent</CODE> 的全局实例，作为所有 HTTP 客户端请求的默认 <CODE>Agent</CODE>。</P>
<H2>http.request(options[, callback])<SPAN><A class="mark" id="http_http_request_options_callback" 
href="http://nodejs.cn/api/http.html#http_http_request_options_callback">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/http.html#http_http_request_options_callback">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/http/http_request_options_callback.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.3.6</SPAN> </DIV>
<UL>
  <LI><CODE>options</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A>
  <UL> 
    <LI><CODE>protocol</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    使用的协议。默认为 <CODE>'http:'</CODE>。</LI>
    <LI><CODE>host</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    请求发送至的服务器的域名或 IP 地址。默认为 <CODE>'localhost'</CODE>。</LI>
    <LI><CODE>hostname</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    <CODE>host</CODE> 的别名。为了支持 <A href="http://nodejs.cn/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><CODE>url.parse()</CODE></A>，<CODE>hostname</CODE> 
    优于 <CODE>host</CODE>。</LI>
    <LI><CODE>family</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    当解析 <CODE>host</CODE> 和 <CODE>hostname</CODE> 时使用的 IP 地址族。 有效值是 
    <CODE>4</CODE> 或 <CODE>6</CODE>。当未指定时，则同时使用 IP v4 和 v6。</LI>
    <LI><CODE>port</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Number&gt;</A> 
    远程服务器的端口。默认为 <CODE>80</CODE>。</LI>
    <LI><CODE>localAddress</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    要绑定到网络连接的本地接口。</LI>
    <LI><CODE>socketPath</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    Unix 域 Socket（使用 host:port 或 socketPath 的其中之一）。</LI>
    <LI><CODE>method</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    一个指定 HTTP 请求方法的字符串。默认为 <CODE>'GET'</CODE>。</LI>
    <LI><CODE>path</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    请求的路径。默认为 <CODE>'/'</CODE>。 应包括查询字符串（如有的话）。如 
    <CODE>'/index.html?page=12'</CODE>。 当请求的路径中包含非法字符时，会抛出异常。
     目前只有空字符会被拒绝，但未来可能会变化。</LI>
    <LI><CODE>headers</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
    一个包含请求头的对象。</LI>
    <LI><CODE>auth</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A> 
    基本身份验证，如 <CODE>'user:password'</CODE> 来计算 Authorization 头。</LI>
    <LI><CODE>agent</CODE> <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_agent">&lt;http.Agent&gt;</A> 
    | <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A> 
    控制 <A 
    href="http://nodejs.cn/api/http.html#http_class_http_agent"><CODE>Agent</CODE></A> 
    的行为。 可能的值有：
    <UL>
      <LI><CODE>undefined</CODE> (默认): 对该主机和端口使用 <A href="http://nodejs.cn/api/http.html#http_http_globalagent"><CODE>http.globalAgent</CODE></A>。</LI>
      <LI><CODE>Agent</CODE> 对象：显式地使用传入的 <CODE>Agent</CODE>。</LI>
      <LI><CODE>false</CODE>: 产生一个新的使用默认值的 <CODE>Agent</CODE>。</LI></UL></LI>
    <LI><CODE>createConnection</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A> 
    当不使用 <CODE>agent</CODE> 选项时，产生一个用于请求的 socket/stream 的函数。 这可以用于避免创建一个自定义的 
    <CODE>Agent</CODE> 类，只是为了覆盖默认的 <CODE>createConnection</CODE> 函数。详见 <A href="http://nodejs.cn/api/http.html#http_agent_createconnection_options_callback"><CODE>agent.createConnection()</CODE></A>。</LI>
    <LI><CODE>timeout</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type">&lt;Integer&gt;</A>: 
    一个数值，指定 socket 超时的毫秒数。 它会在 socket 被连接时设置超时。</LI></UL></LI>
  <LI><CODE>callback</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">&lt;Function&gt;</A></LI>
  <LI>返回: <A class="type" href="http://nodejs.cn/api/http.html#http_class_http_clientrequest">&lt;http.ClientRequest&gt;</A></LI></UL>
<P>Node.js 维护每台服务器的多个连接来进行 HTTP 请求。 该函数允许显式地发出请求。</P>
<P><CODE>options</CODE> 可以是一个对象或一个字符串。 如果 <CODE>options</CODE> 是一个字符串，它会被自动使用 <A 
href="http://nodejs.cn/api/url.html#url_url_parse_urlstring_parsequerystring_slashesdenotehost"><CODE>url.parse()</CODE></A> 
解析。</P>
<P>可选的 <CODE>callback</CODE> 参数会被添加为 <A href="http://nodejs.cn/api/http.html#http_event_response"><CODE>'response'</CODE></A> 
事件的单次监听器。</P>
<P><CODE>http.request()</CODE> 返回一个 <A href="http://nodejs.cn/api/http.html#http_class_http_clientrequest"><CODE>http.ClientRequest</CODE></A> 
类的实例。 <CODE>ClientRequest</CODE> 实例是一个可写流。 如果需要通过 POST 请求上传一个文件，则写入到 
<CODE>ClientRequest</CODE> 对象。</P>
<P>例子：</P>
<PRE><CODE class="lang-js">var postData = querystring.stringify({
  'msg' : 'Hello World!'
});

var options = {
  hostname: 'www.google.com',
  port: 80,
  path: '/upload',
  method: 'POST',
  headers: {
    'Content-Type': 'application/x-www-form-urlencoded',
    'Content-Length': Buffer.byteLength(postData)
  }
};

var req = http.request(options, (res) =&gt; {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding('utf8');
  res.on('data', (chunk) =&gt; {
    console.log(`主体: ${chunk}`);
  });
  res.on('end', () =&gt; {
    console.log('响应中已无数据。');
  });
});

req.on('error', (e) =&gt; {
  console.log(`请求遇到问题: ${e.message}`);
});

// 写入数据到请求主体
req.write(postData);
req.end();
</CODE></PRE>
<P>注意，在例子中调用了 <CODE>req.end()</CODE>。 使用 <CODE>http.request()</CODE> 必须总是调用 
<CODE>req.end()</CODE> 来表明请求已经结束，即使没有数据被写入请求主体。</P>
<P>如果请求过程中遇到任何错误（DNS 解析错误、TCP 级的错误、或实际的 HTTP 解析错误），则在返回的请求对象中会触发 
<CODE>'error'</CODE> 事件。 对于所有的 <CODE>'error'</CODE> 事件，如果没有注册监听器，则抛出错误。</P>
<P>以下是需要注意的几个特殊的请求头。</P>
<UL>
  <LI>
  <P>发送一个 <CODE>'Connection: keep-alive'</CODE> 会通知 
  Node.js，服务器的连接应一直持续到下一个请求。</P></LI>
  <LI>
  <P>发送一个 <CODE>'Content-Length'</CODE> 请求头会禁用默认的块编码。</P></LI>
  <LI>
  <P>发送一个 <CODE>'Expect'</CODE> 请求头会立即发送请求头。 通常情况下，当发送 <CODE>'Expect: 
  100-continue'</CODE> 时，应该设置一个超时并监听 <CODE>'continue'</CODE> 事件。 详见 RFC2616 章节 
  8.2.3。</P></LI>
  <LI>
  <P>发送一个 Authorization 请求头会覆盖使用 <CODE>auth</CODE> 
选项计算基本身份验证。</P></LI></UL></DIV></DIV></DIV><!-- 搜索弹窗 -->   
<DIV id="modal_search_bg"></DIV>
<DIV 
id="modal_search"><INPUT id="modal_search_input" placeholder="API 快速搜索" value=""> 
    
<DIV id="modal_search_result"></DIV></DIV><!-- js -->   <!--[if lt IE 10]><script src="/static/lib/placeholders.js?20170426"></script><![endif]--> 
  
<SCRIPT src="http%20%20Node_js%20API%20文档_files/api.js"></SCRIPT>
 </BODY></HTML>
