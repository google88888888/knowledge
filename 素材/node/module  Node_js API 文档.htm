<!DOCTYPE HTML>
<!-- saved from url=(0033)http://nodejs.cn/api/modules.html -->
<!DOCTYPE html PUBLIC "" ""><HTML lang="zh-cmn-Hans"><HEAD><META 
content="IE=11.0000" http-equiv="X-UA-Compatible">
   
<META charset="utf-8">   <TITLE>module | Node.js API 文档</TITLE>   <LINK href="module%20%20Node_js%20API%20文档_files/api.css" 
rel="stylesheet">   <LINK href="/static/favicon.png" rel="icon" type="image/png" 
sizes="32x32"> 
<META name="GENERATOR" content="MSHTML 11.00.9600.18639"></HEAD> 
<BODY class="alt apidoc" id="api-section-modules">
<DIV class="clearfix" id="content">
<DIV class="interior" id="column2">
<DIV class="interior" id="intro"><A href="http://nodejs.cn/">          Node.js 
中文网         </A>         
<DIV><INPUT id="search_input" placeholder="API 快速搜索" value="">         
</DIV></DIV>
<UL>
  <LI><A class="nav-documentation" href="http://nodejs.cn/api/documentation.html">关于本文档</A></LI>
  <LI><A class="nav-synopsis" 
  href="http://nodejs.cn/api/synopsis.html">用法与例子</A></LI></UL>
<DIV class="line"></DIV>
<UL>
  <LI><A class="nav-assert" href="http://nodejs.cn/api/assert.html">Assert 
  (断言)</A></LI>
  <LI><A class="nav-buffer" 
  href="http://nodejs.cn/api/buffer.html">Buffer</A></LI>
  <LI><A class="nav-addons" href="http://nodejs.cn/api/addons.html">C/C++ 
  插件</A></LI>
  <LI><A class="nav-child_process" href="http://nodejs.cn/api/child_process.html">Child 
  Processes (子进程)</A></LI>
  <LI><A class="nav-cluster" href="http://nodejs.cn/api/cluster.html">Cluster 
  (集群)</A></LI>
  <LI><A class="nav-cli" href="http://nodejs.cn/api/cli.html">CLI 
  (命令行选项)</A></LI>
  <LI><A class="nav-console" href="http://nodejs.cn/api/console.html">Console 
  (控制台)</A></LI>
  <LI><A class="nav-crypto" href="http://nodejs.cn/api/crypto.html">Crypto 
  (加密)</A></LI>
  <LI><A class="nav-debugger" href="http://nodejs.cn/api/debugger.html">Debugger 
  (调试器)</A></LI>
  <LI><A class="nav-dns" href="http://nodejs.cn/api/dns.html">DNS 
  (域名服务器)</A></LI>
  <LI><A class="nav-domain" href="http://nodejs.cn/api/domain.html">Domain 
  (域)</A></LI>
  <LI><A class="nav-errors" href="http://nodejs.cn/api/errors.html">Error 
  (错误)</A></LI>
  <LI><A class="nav-events" href="http://nodejs.cn/api/events.html">Events 
  (事件)</A></LI>
  <LI><A class="nav-fs" href="http://nodejs.cn/api/fs.html">File System 
  (文件系统)</A></LI>
  <LI><A class="nav-globals" href="http://nodejs.cn/api/globals.html">Global 
  (全局变量)</A></LI>
  <LI><A class="nav-http" href="http://nodejs.cn/api/http.html">HTTP</A></LI>
  <LI><A class="nav-https" href="http://nodejs.cn/api/https.html">HTTPS</A></LI>
  <LI><A class="nav-modules active" 
  href="http://nodejs.cn/api/modules.html">Module (模块)</A></LI>
  <LI><A class="nav-net" href="http://nodejs.cn/api/net.html">Net (网络)</A></LI>
  <LI><A class="nav-os" href="http://nodejs.cn/api/os.html">OS (操作系统)</A></LI>
  <LI><A class="nav-path" href="http://nodejs.cn/api/path.html">Path 
  (路径)</A></LI>
  <LI><A class="nav-process" href="http://nodejs.cn/api/process.html">Process 
  (进程)</A></LI>
  <LI><A class="nav-punycode" 
  href="http://nodejs.cn/api/punycode.html">Punycode</A></LI>
  <LI><A class="nav-querystring" 
  href="http://nodejs.cn/api/querystring.html">Query Strings (查询字符串)</A></LI>
  <LI><A class="nav-readline" href="http://nodejs.cn/api/readline.html">Readline 
  (逐行读取)</A></LI>
  <LI><A class="nav-repl" href="http://nodejs.cn/api/repl.html">REPL 
  (交互式解释器)</A></LI>
  <LI><A class="nav-stream" href="http://nodejs.cn/api/stream.html">Stream 
  (流)</A></LI>
  <LI><A class="nav-string_decoder" href="http://nodejs.cn/api/string_decoder.html">String 
  Decoder (字符串解码器)</A></LI>
  <LI><A class="nav-timers" href="http://nodejs.cn/api/timers.html">Timer 
  (定时器)</A></LI>
  <LI><A class="nav-tls" href="http://nodejs.cn/api/tls.html">TLS 
  (安全传输层)</A></LI>
  <LI><A class="nav-tty" href="http://nodejs.cn/api/tty.html">TTY (终端)</A></LI>
  <LI><A class="nav-dgram" href="http://nodejs.cn/api/dgram.html">UDP/Datagram 
  (数据报)</A></LI>
  <LI><A class="nav-url" href="http://nodejs.cn/api/url.html">URL</A></LI>
  <LI><A class="nav-util" href="http://nodejs.cn/api/util.html">Util 
  (实用工具)</A></LI>
  <LI><A class="nav-v8" href="http://nodejs.cn/api/v8.html">V8</A></LI>
  <LI><A class="nav-vm" href="http://nodejs.cn/api/vm.html">VM (虚拟机)</A></LI>
  <LI><A class="nav-zlib" href="http://nodejs.cn/api/zlib.html">ZLIB 
  (压缩)</A></LI></UL>
<DIV class="line"></DIV></DIV>
<DIV class="interior" id="column1" data-id="modules"><HEADER>
<H1>Node.js v6.10.3 文档</H1>
<DIV id="gtoc">
<P><A name="toc" href="http://nodejs.cn/api/">返回文档首页</A>             <!--<a href="/api/all.html">单页面显示</a> |--> 
            <!--<a href="/api/modules.json">JSON格式</a> |-->             <!--<a href="/api/en/modules.html">查看英文版</a>--> 
          </P></DIV>
<HR>
</HEADER>
<DIV id="toc">
<H2>目录</H2>
<UL>
  <LI><SPAN class="stability_2"><A href="http://nodejs.cn/api/modules.html#modules_modules">module 
  (模块)</A></SPAN>
  <UL> 
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_accessing_the_main_module">访问主模块</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_addenda_package_manager_tips">附录：包管理器的技巧</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_all_together">总结</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_caching">缓存</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_caching_caveats">模块缓存的注意事项</A></SPAN></LI></UL></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_core_modules">核心模块</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_cycles">循环</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_file_modules">文件模块</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_folders_as_modules">目录作为模块</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_loading_from_node_modules_folders">从 
    <CODE>node_modules</CODE> 目录加载</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_loading_from_the_global_folders">从全局目录加载</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper">模块包装器</A></SPAN></LI>
    <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_the_module_object">module 
    对象</A></SPAN>
    <UL> 
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_children">module.children</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_exports">module.exports</A></SPAN>
      <UL> 
        <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_exports_shortcut">exports 
        快捷方式</A></SPAN></LI></UL></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_filename">module.filename</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_id">module.id</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_loaded">module.loaded</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_parent">module.parent</A></SPAN></LI>
      <LI><SPAN class="stability_undefined"><A href="http://nodejs.cn/api/modules.html#modules_module_require_id">module.require(id)</A></SPAN></LI></UL></LI></UL></LI></UL></DIV>
<DIV id="apicontent">
<H1>module (模块)<SPAN><A class="mark" id="modules_modules" href="http://nodejs.cn/api/modules.html#modules_modules">#</A></SPAN></H1>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_modules">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/modules.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<PRE class="api_stability api_stability_2"><A href="http://nodejs.cn/api/documentation.html#documentation_stability_index">稳定性: 2</A> - 稳定的</PRE><!--name=module--> 
<P>Node.js 有一个简单的模块加载系统。 在 Node.js 中，文件和模块是一一对应的（每个文件被视为一个独立的模块）。</P>
<P>例子，假设有一个名为 <CODE>foo.js</CODE> 的文件：</P>
<PRE><CODE class="lang-js">const circle = require('./circle.js');
console.log(`半径为 4 的圆的面积是 ${circle.area(4)}`);
</CODE></PRE>
<P>在第一行中，<CODE>foo.js</CODE> 加载了同一目录下的 <CODE>circle.js</CODE> 模块。</P>
<P><CODE>circle.js</CODE> 文件的内容为：</P>
<PRE><CODE class="lang-js">const { PI } = Math;

exports.area = (r) =&gt; PI * r * r;

exports.circumference = (r) =&gt; 2 * PI * r;
</CODE></PRE>
<P><CODE>circle.js</CODE> 模块导出了 <CODE>area()</CODE> 和 
<CODE>circumference()</CODE> 两个函数。 要想添加函数和对象到模块根，可以将它们添加到特殊的 
<CODE>exports</CODE> 对象。</P>
<P>模块内的本地变量是私有的，因为模块被 Node.js 包装在一个函数中（详见<A href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper">模块包装器</A>）。
 在这个例子中，变量 <CODE>PI</CODE> 是 <CODE>circle.js</CODE> 私有的。</P>
<P>如果希望模块根导出为一个函数（比如构造函数）或一次导出一个完整的对象而不是每次都创建一个属性，可以把它赋值给 
<CODE>module.exports</CODE> 而不是 <CODE>exports</CODE>。</P>
<P>如下，<CODE>bar.js</CODE> 会用到 <CODE>square</CODE> 模块，<CODE>square</CODE> 
导出一个构造函数：</P>
<PRE><CODE class="lang-js">const square = require('./square.js');
const mySquare = square(2);
console.log(`正方形的面积是 ${mySquare.area()}`);
</CODE></PRE>
<P><CODE>square</CODE> 模块定义在 <CODE>square.js</CODE> 中：</P>
<PRE><CODE class="lang-js">// 赋值给 `exports` 不会修改模块，必须使用 `module.exports`
module.exports = (width) =&gt; {
  return {
    area: () =&gt; width * width
  };
};
</CODE></PRE>
<P>模块系统在 <CODE>require('module')</CODE> 模块中实现。</P>
<H2>访问主模块<SPAN><A class="mark" id="modules_accessing_the_main_module" href="http://nodejs.cn/api/modules.html#modules_accessing_the_main_module">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_accessing_the_main_module">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/accessing_the_main_module.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>当 Node.js 直接运行一个文件时，<CODE>require.main</CODE> 会被设为它的 <CODE>module</CODE>。
 这意味着你可以通过如下检测确定一个文件是否直接运行：</P>
<PRE><CODE class="lang-js">require.main === module
</CODE></PRE>
<P>对于 <CODE>foo.js</CODE> 文件，如果通过 <CODE>node foo.js</CODE> 运行则为 
<CODE>true</CODE>，但如果通过 <CODE>require('./foo')</CODE> 运行则为 
<CODE>false</CODE>。</P>
<P>因为 <CODE>module</CODE> 提供了一个 <CODE>filename</CODE> 属性（通常等同于 
<CODE>__filename</CODE>），所以可以通过检查 <CODE>require.main.filename</CODE> 
来获取当前应用程序的入口点。</P>
<H2>附录：包管理器的技巧<SPAN><A class="mark" id="modules_addenda_package_manager_tips" 
href="http://nodejs.cn/api/modules.html#modules_addenda_package_manager_tips">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_addenda_package_manager_tips">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/addenda_package_manager_tips.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>Node.js 的 <CODE>require()</CODE> 函数的语义被设计得足够通用化，可以支持许多合理的目录结构。 包管理器程序（如 
<CODE>dpkg</CODE>、<CODE>rpm</CODE> 和 <CODE>npm</CODE>）可以不用修改就能够从 Node.js 
模块构建本地包。</P>
<P>以下是一个推荐的目录结构：</P>
<P>假设想要在 <CODE>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</CODE> 
目录中保存一个特定版本的包的内容。</P>
<P>包可以依赖于其他包。 为了安装包 <CODE>foo</CODE>，可能需要安装一个指定版本的 <CODE>bar</CODE> 包。 
<CODE>bar</CODE> 包也可能有依赖，且在某些情况下，依赖可能有冲突或形成循环。</P>
<P>因为 Node.js 会查找它所加载的模块的实际路径（也就是说会解析符号链接），然后在 <CODE>node_modules</CODE> 
目录中寻找它们的依赖，<A href="http://nodejs.cn/api/modules.html#modules_loading_from_node_modules_folders">如下所述</A>，这种情况使用以下体系结构很容易解决：</P>
<UL>
  <LI><CODE>/usr/lib/node/foo/1.2.3/</CODE> - <CODE>foo</CODE> 包的内容，版本 
  1.2.3。</LI>
  <LI><CODE>/usr/lib/node/bar/4.3.2/</CODE> - <CODE>foo</CODE> 依赖的 
  <CODE>bar</CODE> 包的内容。</LI>
  <LI><CODE>/usr/lib/node/foo/1.2.3/node_modules/bar</CODE> - 
  <CODE>/usr/lib/node/bar/4.3.2/</CODE> 的符号链接。</LI>
  <LI><CODE>/usr/lib/node/bar/4.3.2/node_modules/*</CODE> - <CODE>bar</CODE> 
  所依赖的包的符号链接</LI></UL>
<P>因此，即便存在循环依赖或依赖冲突，每个模块还是可以获得它所依赖的包的一个可用版本。</P>
<P>当 <CODE>foo</CODE> 包中的代码调用 <CODE>require('bar')</CODE>，它会获得符号链接 
<CODE>/usr/lib/node/foo/1.2.3/node_modules/bar</CODE> 指向的版本。 然后，当 
<CODE>bar</CODE> 包中的代码调用 <CODE>require('queue')</CODE>，它会获得符号链接 
<CODE>/usr/lib/node/bar/4.3.2/node_modules/quux</CODE> 指向的版本。</P>
<P>此外，为了进一步优化模块查找过程，不要将包直接放在 <CODE>/usr/lib/node</CODE> 目录中，而是将它们放在 
<CODE>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</CODE> 目录中。 这样 Node.js 
就不会在 <CODE>/usr/node_modules</CODE> 或 <CODE>/node_modules</CODE> 目录中查找缺失的依赖。</P>
<P>为了使模块在 Node.js 的 REPL 中可用，可能需要将 <CODE>/usr/lib/node_modules</CODE> 目录添加到 
<CODE>$NODE_PATH</CODE> 环境变量中。 由于在 <CODE>node_modules</CODE> 目录中查找模块使用的是相对路径，而调用 
<CODE>require()</CODE> 的文件是基于实际路径的，因此包本身可以放在任何地方。</P>
<H2>总结<SPAN><A class="mark" id="modules_all_together" href="http://nodejs.cn/api/modules.html#modules_all_together">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_all_together">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/all_together.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>想要获得调用 <CODE>require()</CODE> 时加载的确切的文件名，使用 <CODE>require.resolve()</CODE> 
函数。</P>
<P>综上所述，以下用伪代码描述的高级算法，解释 <CODE>require.resolve()</CODE> 做了些什么：</P>
<PRE><CODE class="lang-txt">从 Y 路径的模块 require(X)
1. 如果 X 是一个核心模块，
   a. 返回核心模块
   b. 结束
2. 如果 X 是以 '/' 开头
   a. 设 Y 为文件系统根目录
3. 如果 X 是以 './' 或 '/' 或 '../' 开头
   a. 加载文件(Y + X)
   b. 加载目录(Y + X)
4. 加载Node模块(X, dirname(Y))
5. 抛出 "未找到"

加载文件(X)
1. 如果 X 是一个文件，加载 X 作为 JavaScript 文本。结束
2. 如果 X.js 是一个文件，加载 X.js 作为 JavaScript 文本。结束
3. 如果 X.json 是一个文件，解析 X.json 成一个 JavaScript 对象。结束
4. 如果 X.node 是一个文件，加载 X.node 作为二进制插件。结束

加载索引(X)
1. 如果 X/index.js 是一个文件，加载 X/index.js 作为 JavaScript 文本。结束
3. 如果 X/index.json  是一个文件，解析 X/index.json 成一个 JavaScript 对象。结束
4. 如果 X/index.node 是一个文件，加载 X/index.node 作为二进制插件。结束

加载目录(X)
1. 如果 X/package.json 是一个文件，
   a. 解析 X/package.json，查找 "main" 字段
   b. let M = X + (json main 字段)
   c. 加载文件(M)
   d. 加载索引(M)
2. 加载索引(X)

加载Node模块(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. 加载文件(DIR/X)
   b. 加载目录(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let I = count of PARTS - 1
3. let DIRS = []
4. while I &gt;= 0,
   a. if PARTS[I] = "node_modules" CONTINUE
   b. DIR = path join(PARTS[0 .. I] + "node_modules")
   c. DIRS = DIRS + DIR
   d. let I = I - 1
5. return DIRS
</CODE></PRE>
<H2>缓存<SPAN><A class="mark" id="modules_caching" href="http://nodejs.cn/api/modules.html#modules_caching">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_caching">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/caching.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 <CODE>require('foo')</CODE> 
都解析到同一文件，则返回相同的对象。</P>
<P>多次调用 <CODE>require(foo)</CODE> 不会导致模块的代码被执行多次。 这是一个重要的特性。 借助它, 
可以返回“部分完成”的对象，从而允许加载传递的依赖, 即使它们会导致循环。</P>
<P>如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。</P>
<H3>模块缓存的注意事项<SPAN><A class="mark" id="modules_module_caching_caveats" href="http://nodejs.cn/api/modules.html#modules_module_caching_caveats">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_caching_caveats">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_caching_caveats.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>模块是基于其解析的文件名进行缓存的。 由于调用模块的位置的不同，模块可能被解析成不同的文件名（比如从 <CODE>node_modules</CODE> 
目录加载），这样就不能保证 <CODE>require('foo')</CODE> 总能返回完全相同的对象。</P>
<P>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，但缓存仍然会将它们视为不同的模块，并多次重新加载。
 例如，<CODE>require('./foo')</CODE> 和 <CODE>require('./FOO')</CODE> 返回两个不同的对象，而不会管 
<CODE>./foo</CODE> 和 <CODE>./FOO</CODE> 是否是相同的文件。</P>
<H2>核心模块<SPAN><A class="mark" id="modules_core_modules" href="http://nodejs.cn/api/modules.html#modules_core_modules">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_core_modules">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/core_modules.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>Node.js 有些模块会被编译成二进制。 这些模块别的地方有更详细的描述。</P>
<P>核心模块定义在 Node.js 源代码的 <CODE>lib/</CODE> 目录下。</P>
<P><CODE>require()</CODE> 总是会优先加载核心模块。 例如，<CODE>require('http')</CODE> 始终返回内置的 
HTTP 模块，即使有同名文件。</P>
<H2>循环<SPAN><A class="mark" id="modules_cycles" href="http://nodejs.cn/api/modules.html#modules_cycles">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_cycles">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/cycles.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>当循环调用 <CODE>require()</CODE> 时，一个模块可能在未完成执行时被返回。</P>
<P>例如以下情况:</P>
<P><CODE>a.js</CODE>:</P>
<PRE><CODE class="lang-js">console.log('a 开始');
exports.done = false;
const b = require('./b.js');
console.log('在 a 中，b.done = %j', b.done);
exports.done = true;
console.log('a 结束');
</CODE></PRE>
<P><CODE>b.js</CODE>:</P>
<PRE><CODE class="lang-js">console.log('b 开始');
exports.done = false;
const a = require('./a.js');
console.log('在 b 中，a.done = %j', a.done);
exports.done = true;
console.log('b 结束');
</CODE></PRE>
<P><CODE>main.js</CODE>:</P>
<PRE><CODE class="lang-js">console.log('main 开始');
const a = require('./a.js');
const b = require('./b.js');
console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);
</CODE></PRE>
<P>当 <CODE>main.js</CODE> 加载 <CODE>a.js</CODE> 时，<CODE>a.js</CODE> 又加载 
<CODE>b.js</CODE>。 此时，<CODE>b.js</CODE> 会尝试去加载 <CODE>a.js</CODE>。
 为了防止无限的循环，会返回一个 <CODE>a.js</CODE> 的 <CODE>exports</CODE> 对象的 
<STRONG>未完成的副本</STRONG> 给 <CODE>b.js</CODE> 模块。 然后 <CODE>b.js</CODE> 完成加载，并将 
<CODE>exports</CODE> 对象提供给 <CODE>a.js</CODE> 模块。</P>
<P>当 <CODE>main.js</CODE> 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：</P>
<PRE><CODE class="lang-txt">$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
</CODE></PRE>
<P>如果你的程序里有循环的模块依赖，确保它们按计划执行。</P>
<H2>文件模块<SPAN><A class="mark" id="modules_file_modules" href="http://nodejs.cn/api/modules.html#modules_file_modules">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_file_modules">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/file_modules.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>如果按确切的文件名没有找到模块，则 Node.js 会尝试带上 <CODE>.js</CODE>、<CODE>.json</CODE> 或 
<CODE>.node</CODE> 拓展名再加载。</P>
<P><CODE>.js</CODE> 文件会被解析为 JavaScript 文本文件，<CODE>.json</CODE> 文件会被解析为 JSON 
文本文件。 <CODE>.node</CODE> 文件会被解析为通过 <CODE>dlopen</CODE> 加载的编译后的插件模块。</P>
<P>以 <CODE>'/'</CODE> 为前缀的模块是文件的绝对路径。
 例如，<CODE>require('/home/marco/foo.js')</CODE> 会加载 
<CODE>/home/marco/foo.js</CODE> 文件。</P>
<P>以 <CODE>'./'</CODE> 为前缀的模块是相对于调用 <CODE>require()</CODE> 的文件的。
 也就是说，<CODE>circle.js</CODE> 必须和 <CODE>foo.js</CODE> 在同一目录下以便于 
<CODE>require('./circle')</CODE> 找到它。</P>
<P>当没有以 <CODE>'/'</CODE>、<CODE>'./'</CODE> 或 <CODE>'../'</CODE> 
开头来表示文件时，这个模块必须是一个核心模块或加载自 <CODE>node_modules</CODE> 目录。</P>
<P>如果给定的路径不存在，则 <CODE>require()</CODE> 会抛出一个 <CODE>code</CODE> 属性为 
<CODE>'MODULE_NOT_FOUND'</CODE> 的 <A href="http://nodejs.cn/api/errors.html#errors_class_error"><CODE>Error</CODE></A>。</P>
<H2>目录作为模块<SPAN><A class="mark" id="modules_folders_as_modules" href="http://nodejs.cn/api/modules.html#modules_folders_as_modules">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_folders_as_modules">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/folders_as_modules.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>可以把程序和库放到一个单独的目录，然后提供一个单一的入口来指向它。 把目录递给 <CODE>require()</CODE> 
作为一个参数，有三种方式。</P>
<P>第一种方式是在根目录下创建一个 <CODE>package.json</CODE> 文件，并指定一个 <CODE>main</CODE> 模块。
 例子，<CODE>package.json</CODE> 文件类似：</P>
<PRE><CODE class="lang-json">{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
</CODE></PRE>
<P>如果这是在 <CODE>./some-library</CODE> 目录中，则 
<CODE>require('./some-library')</CODE> 会试图加载 
<CODE>./some-library/lib/some-library.js</CODE>。</P>
<P>这就是 Node.js 处理 <CODE>package.json</CODE> 文件的方式。</P>
<P>注意：如果 <CODE>package.json</CODE> 中 <CODE>"main"</CODE> 
入口指定的文件不存在，则无法解析，Node.js 会将模块视为不存在，并抛出默认错误：</P>
<PRE><CODE class="lang-txt">Error: Cannot find module 'some-library'
</CODE></PRE>
<P>如果目录里没有 <CODE>package.json</CODE> 文件，则 Node.js 就会试图加载目录下的 
<CODE>index.js</CODE> 或 <CODE>index.node</CODE> 文件。 例如，如果上面的例子中没有 
<CODE>package.json</CODE> 文件，则 <CODE>require('./some-library')</CODE> 会试图加载：</P>
<UL>
  <LI><CODE>./some-library/index.js</CODE></LI>
  <LI><CODE>./some-library/index.node</CODE></LI></UL>
<H2>从 <CODE>node_modules</CODE> 目录加载<SPAN><A class="mark" id="modules_loading_from_node_modules_folders" 
href="http://nodejs.cn/api/modules.html#modules_loading_from_node_modules_folders">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_loading_from_node_modules_folders">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/loading_from_node_modules_folders.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!--type=misc--> 
<P>如果传递给 <CODE>require()</CODE> 的模块标识符不是一个<A href="http://nodejs.cn/api/modules.html#modules_core_modules">核心模块</A>，也没有以 
<CODE>'/'</CODE> 、 <CODE>'../'</CODE> 或 <CODE>'./'</CODE> 开头，则 Node.js 
会从当前模块的父目录开始，尝试从它的 <CODE>/node_modules</CODE> 目录里加载模块。 Node.js 不会附加 
<CODE>node_modules</CODE> 到一个已经以 <CODE>node_modules</CODE> 结尾的路径上。</P>
<P>如果还是没有找到，则移动到再上一层父目录，直到文件系统的根目录。</P>
<P>例子，如果在 <CODE>'/home/ry/projects/foo.js'</CODE> 文件里调用了 
<CODE>require('bar.js')</CODE>，则 Node.js 会按以下顺序查找：</P>
<UL>
  <LI><CODE>/home/ry/projects/node_modules/bar.js</CODE></LI>
  <LI><CODE>/home/ry/node_modules/bar.js</CODE></LI>
  <LI><CODE>/home/node_modules/bar.js</CODE></LI>
  <LI><CODE>/node_modules/bar.js</CODE></LI></UL>
<P>这使得程序本地化它们的依赖，避免它们产生冲突。</P>
<P>通过在模块名后包含一个路径后缀，可以请求特定的文件或分布式的子模块。
 例如，<CODE>require('example-module/path/to/file')</CODE> 会把 
<CODE>path/to/file</CODE> 解析成相对于 <CODE>example-module</CODE> 的位置。
 后缀路径同样遵循模块的解析语法。</P>
<H2>从全局目录加载<SPAN><A class="mark" id="modules_loading_from_the_global_folders" 
href="http://nodejs.cn/api/modules.html#modules_loading_from_the_global_folders">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_loading_from_the_global_folders">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/loading_from_the_global_folders.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>如果 <CODE>NODE_PATH</CODE> 环境变量被设为一个以冒号分割的绝对路径列表，则当在其他地方找不到模块时 Node.js 
会搜索这些路径。 （注意：在 Windows 系统中，<CODE>NODE_PATH</CODE> 是以分号间隔的。）</P>
<P>在当前的<A 
href="http://nodejs.cn/api/modules.html#modules_all_together">模块解析</A>算法运行之前，<CODE>NODE_PATH</CODE> 
最初是创建来支持从不同路径加载模块的。</P>
<P>虽然 <CODE>NODE_PATH</CODE> 仍然被支持，但现在不太需要，因为 Node.js 生态系统已制定了一套存放依赖模块的约定。
 有时当人们没意识到 <CODE>NODE_PATH</CODE> 必须被设置时，依赖 <CODE>NODE_PATH</CODE> 
的部署会出现意料之外的行为。 有时一个模块的依赖会改变，导致在搜索 <CODE>NODE_PATH</CODE> 时加载了不同的版本（甚至不同的模块）。</P>
<P>此外，Node.js 还会搜索以下位置：</P>
<UL>
  <LI>1: <CODE>$HOME/.node_modules</CODE></LI>
  <LI>2: <CODE>$HOME/.node_libraries</CODE></LI>
  <LI>3: <CODE>$PREFIX/lib/node</CODE></LI></UL>
<P>其中 <CODE>$HOME</CODE> 是用户的主目录，<CODE>$PREFIX</CODE> 是 Node.js 里配置的 
<CODE>node_prefix</CODE>。</P>
<P>这些主要是历史原因。 <STRONG>强烈建议将所有的依赖放在 <CODE>node_modules</CODE> 目录。</STRONG>
 它们将会更快地加载，且更可靠。</P>
<H2>模块包装器<SPAN><A class="mark" id="modules_the_module_wrapper" href="http://nodejs.cn/api/modules.html#modules_the_module_wrapper">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_the_module_wrapper">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/the_module_wrapper.md" 
target="_blank" rel="nofollow">参与翻译</A></P><!-- type=misc --> 
<P>在执行模块代码之前，Node.js 会使用一个如下的函数包装器将其包装：</P>
<PRE><CODE class="lang-js">(function (exports, require, module, __filename, __dirname) {
// 你的模块代码实际上在这里
});
</CODE></PRE>
<P>通过这样做，Node.js 实现了以下几点：</P>
<UL>
  <LI>它保持了顶层的变量（用 <CODE>var</CODE>、<CODE>const</CODE> 或 <CODE>let</CODE> 
  定义）作用在模块范围内，而不是全局对象。</LI>
  <LI>它有助于提供一些看似全局的但实际上是模块特定的变量，例如：
  <UL>
    <LI>实现者可以使用 <CODE>module</CODE> 和 <CODE>exports</CODE> 对象从模块中导出值。</LI>
    <LI>快捷变量 <CODE>__filename</CODE> 和 <CODE>__dirname</CODE> 
    包含模块的绝对文件名和目录路径。</LI></UL></LI></UL>
<H2>module 对象<SPAN><A class="mark" id="modules_the_module_object" href="http://nodejs.cn/api/modules.html#modules_the_module_object">#</A></SPAN></H2>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_the_module_object">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/the_module_object.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV><!-- type=var --> <!-- name=module --> 
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P>在每个模块中，<CODE>module</CODE> 的自由变量是一个指向表示当前模块的对象的引用。
 为了方便，<CODE>module.exports</CODE> 也可以通过全局模块的 <CODE>exports</CODE> 对象访问。 
<CODE>module</CODE> 实际上不是全局的，而是每个模块本地的。</P>
<H3>module.children<SPAN><A class="mark" id="modules_module_children" href="http://nodejs.cn/api/modules.html#modules_module_children">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_children">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_children.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">&lt;Array&gt;</A></LI></UL>
<P>被该模块引用的模块对象。</P>
<H3>module.exports<SPAN><A class="mark" id="modules_module_exports" href="http://nodejs.cn/api/modules.html#modules_module_exports">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_exports">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_exports.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A></LI></UL>
<P><CODE>module.exports</CODE> 对象是由模块系统创建的。 有时这是难以接受的；许多人希望他们的模块成为某个类的实例。
 为了实现这个，需要将期望导出的对象赋值给 <CODE>module.exports</CODE>。 注意，将期望的对象赋值给 
<CODE>exports</CODE> 会简单地重新绑定到本地 <CODE>exports</CODE> 变量上，这可能不是你想要的。</P>
<P>例子，假设创建了一个名为 <CODE>a.js</CODE> 的模块：</P>
<PRE><CODE class="lang-js">const EventEmitter = require('events');

module.exports = new EventEmitter();

// 处理一些工作，并在一段时间后从模块自身触发 'ready' 事件。
setTimeout(() =&gt; {
  module.exports.emit('ready');
}, 1000);
</CODE></PRE>
<P>然后，在另一个文件中可以这么做：</P>
<PRE><CODE class="lang-js">const a = require('./a');
a.on('ready', () =&gt; {
  console.log('模块 a 已准备好');
});
</CODE></PRE>
<P>注意，对 <CODE>module.exports</CODE> 的赋值必须立即完成。 不能在任何回调中完成。 以下是无效的：</P>
<P>x.js:</P>
<PRE><CODE class="lang-js">setTimeout(() =&gt; {
  module.exports = { a: 'hello' };
}, 0);
</CODE></PRE>
<P>y.js:</P>
<PRE><CODE class="lang-js">const x = require('./x');
console.log(x.a);
</CODE></PRE>
<H4>exports 快捷方式<SPAN><A class="mark" id="modules_exports_shortcut" href="http://nodejs.cn/api/modules.html#modules_exports_shortcut">#</A></SPAN></H4>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_exports_shortcut">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/exports_shortcut.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<P><CODE>exports</CODE> 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 
<CODE>module.exports</CODE> 的值。</P>
<P>它有一个快捷方式，以便 <CODE>module.exports.f = ...</CODE> 可以被更简洁地写成 <CODE>exports.f = 
...</CODE>。 注意，就像任何变量，如果一个新的值被赋值给 <CODE>exports</CODE>，它就不再绑定到 
<CODE>module.exports</CODE>：</P>
<PRE><CODE class="lang-js">module.exports.hello = true; // 从被引用的模块导出
exports = { hello: false };  // 不导出，只在模块内有效
</CODE></PRE>
<P>当 <CODE>module.exports</CODE> 属性被一个新的对象完全替代时，也会重新赋值 
<CODE>exports</CODE>，例如：</P>
<PRE><CODE class="lang-js">module.exports = exports = function Constructor() {
    // ... 及其他
</CODE></PRE>
<P>为了解释这个行为，想象对 <CODE>require()</CODE> 的假设实现，它跟 <CODE>require()</CODE> 
的实际实现相等类似：</P>
<PRE><CODE class="lang-js">function require(/* ... */) {
  const module = { exports: {} };
  ((module, exports) =&gt; {
    // 你的模块代码在这。在这个例子中，定义了一个函数。
    function someFunc() {}
    exports = someFunc;
    // 此时，exports 不再是一个 module.exports 的快捷方式，
    // 且这个模块依然导出一个空的默认对象。
    module.exports = someFunc;
    // 此时，该模块导出 someFunc，而不是默认对象。
  })(module, module.exports);
  return module.exports;
}
</CODE></PRE>
<H3>module.filename<SPAN><A class="mark" id="modules_module_filename" href="http://nodejs.cn/api/modules.html#modules_module_filename">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_filename">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_filename.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>模块的完全解析后的文件名。</P>
<H3>module.id<SPAN><A class="mark" id="modules_module_id" href="http://nodejs.cn/api/modules.html#modules_module_id">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_id">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_id.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI></UL>
<P>模块的标识符。 通常是完全解析后的文件名。</P>
<H3>module.loaded<SPAN><A class="mark" id="modules_module_loaded" href="http://nodejs.cn/api/modules.html#modules_module_loaded">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_loaded">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_loaded.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type">&lt;Boolean&gt;</A></LI></UL>
<P>模块是否已经加载完成，或正在加载中。</P>
<H3>module.parent<SPAN><A class="mark" id="modules_module_parent" href="http://nodejs.cn/api/modules.html#modules_module_parent">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_parent">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_parent.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.1.16</SPAN> </DIV>
<UL>
  <LI><A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  模块对象</LI></UL>
<P>最先引用该模块的模块。</P>
<H3>module.require(id)<SPAN><A class="mark" id="modules_module_require_id" href="http://nodejs.cn/api/modules.html#modules_module_require_id">#</A></SPAN></H3>
<P style="font-size: 12px; margin-top: -1em;"><A href="http://nodejs.cn/api/en/modules.html#modules_module_require_id">查看英文版</A> 
/ <A href="https://github.com/nodejscn/node-api-cn/edit/master/modules/module_require_id.md" 
target="_blank" rel="nofollow">参与翻译</A></P>
<DIV class="api_metadata"><SPAN>新增于: v0.5.1</SPAN> </DIV>
<UL>
  <LI><CODE>id</CODE> <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#String_type">&lt;String&gt;</A></LI>
  <LI>返回: <A class="type" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object">&lt;Object&gt;</A> 
  已解析的模块的 <CODE>module.exports</CODE></LI></UL>
<P><CODE>module.require</CODE> 方法提供了一种类似 <CODE>require()</CODE> 
从原始模块被调用的加载模块的方式。</P>
<P>注意，为了做到这个，你必须获得一个 <CODE>module</CODE> 对象的引用。 因为 <CODE>require()</CODE> 会返回 
<CODE>module.exports</CODE>，且 <CODE>module</CODE> 
<STRONG>只</STRONG>在一个特定的模块代码中有效，所以为了使用它，必须显式地导出。</P></DIV></DIV></DIV><!-- 搜索弹窗 --> 
  
<DIV id="modal_search_bg"></DIV>
<DIV 
id="modal_search"><INPUT id="modal_search_input" placeholder="API 快速搜索" value=""> 
    
<DIV id="modal_search_result"></DIV></DIV><!-- js -->   <!--[if lt IE 10]><script src="/static/lib/placeholders.js?20170426"></script><![endif]--> 
  
<SCRIPT src="module%20%20Node_js%20API%20文档_files/api.js"></SCRIPT>
 </BODY></HTML>
