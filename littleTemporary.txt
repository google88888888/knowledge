盒模型
（1）两种盒模型：标准盒模型，IE盒模型
（2）
标准盒模型：content + padding + border + margin，width=content
IE盒模型：content + padding + border + margin, width=content + padding + border 
（3）设置统一盒模型
标准盒模型：box-sizing:content-box
IE盒模型：box-sizing:border-box 



深拷贝的实现方式
const a = [
	{
		name:1,
		value:1,
		children:[
			{
				name:11,
				value:11,
				children:[
					{
						value:111,
						name:111
					}
				]
			},
			{
				name:12,
				value:12,
				children:[
					{
						value:111,name:111
					}
				]
			}
		]
	},
	{
		name:2,
		value:2,
		children:[
			{
				name:21,
				value:21
			}
		]
	}
]
（1）const b = JSON.parse(JSON.stringify(a));
（2）
	function deepClone(obj) {
		let newObj = obj instanceof Array ? []:{};
		if(typeof obj !== 'object') {
			return obj;
		}else{
			for(var i in obj) {
				newObj[i] = typeof obj[i] === 'object' ? deepClone(obj[i]) : obj[i];
			}
		}
		return newObj;
	};
	const b = deepClone(a);





setState同步异步及执行问题
（1）setState在react生命周期是异步的，在原生js或异步函数是同步的。
（2） 下面组件中，render被执行了几次，a和b分别输出什么
class Test extends Component {
	constructor(props){
		super(props);
		this.state = {
			a:1,
			b:2
		}
	}
	componentDidMount(){
		this.setState({
			b:1
		});
		this.setState({
			b:2
		},()=>{
			this,setState({
				a:1
			})
		})
		this.setState({
			a:2
		});
		this.setState({
			a:3
		})	
		this.setState({
			a:4
		},()=>{
			this.state({
				b:5
			})
		})
		setTimeout(()=>{
			this.setState({
          		a:7,
				b:7
			});
			this.setState({
          		b:8
			});
		})
		setTimeout(()=>{
			this.setState({
				b:6
			});
		})
	}
	render(){
		const { a, b} = this.state;
		return (
			<>
				{a}
				{b}
			</>
		)
	}
}
上面组件render被执行了6次。分别为初始化执行1次，在react生命周期componentDidMount执行1次，在setState两次回调中执行1次,在setTimout三次setState执行3次，a，b分别输出7，6。



Promise中如果没有resolve或者reject，那么将一直处于pending状态，不会执行then




BFC
https://zhuanlan.zhihu.com/p/25321647
https://blog.csdn.net/sinat_36422236/article/details/88763187

















































































































