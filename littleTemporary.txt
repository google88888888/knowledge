浏览器进程线程及fiber及对reac生命周期的影响
（1）看完并整理完
https://segmentfault.com/a/1190000012925872
（2）看完并整理完
https://segmentfault.com/a/1190000018250127
（3）看完并整理完
https://segmentfault.com/a/1190000020035950
https://www.jianshu.com/p/0d9f558959c3

（1）浏览器进程线程
（1.1）
进程是cpu资源分配的最小单位
线程是cpu调度的最小单位

（1.2）浏览器包含的进程
（1.2.1）Browser进程：主进程，只有一个，作用：
（a）界面显示，与用户交互，如前进，后退等
（b）每个Tab页的管理，创建和销毁其他进程
（c）将Renderer进程得到的内存中的Bitmap，绘制到界面
（d）网络资源的管理，下载等
（1.2.2）第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建
（1.2.3）GPU进程：最多一个，用于3D绘制等
（1.2.4）Renderer进程：渲染进程，浏览器内核，默认每个Tab页一个Renderer进程，互不影响，内部多线程，作用：
（a）页面渲染，js执行，事件循环等
（1.2.5）SharedWorker进程
（a）所有Tab页共享，所有Renderer进程共享

（1.3）浏览器有时会将多个进程合并。比如打开多个空白Tab页，浏览器会将多个空白Tab页合并成一个进程

（1.4）浏览器多进程优势
（1.4.1）避免单个page crash影响整个浏览器
（1.4.2）避免第三方插件crash影响整个浏览器
（1.4.3）多进程充分利用多核优势
（1.4.4）方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

（1.5）Renderer进程包含的线程：

（1.5.1）GUI渲染线程
（a）页面渲染，解析html，css，构建dom树、style树、render树，布局和绘制等。
（b）Repaint、reflow
（c）GUI渲染线程与JS引擎线程是互斥的，GUI渲染被保存在一个队列中等到JS引擎空闲时被立即执行。如果JS引擎执行时间过长，GUI渲染阻塞，fiber解决此问题。

（1.5.2）JS引擎线程
（a）即JS内核，如V8引擎
（b）解析Javascript，运行代码。
（c）一直等待任务队列中任务到来，加以处理

（1.5.3）事件触发线程
（a）控制事件循环（JS引擎线程忙不过来，需另开线程协助）
（b）当JS引擎执行代码块如setTimeOut（也可来自Renderer进程的其他线程，如鼠标点击、AJAX异步请求等），会将对应事件添加到事件触发线程中
（c）当对应事件符合触发条件被触发时，事件触发线程会把对应事件添加到任务队列的队尾，等待JS引擎空闲时加以处理

（1.5.4）定时触发器线程
（a）setInterval与setTimeout计时
（b）W3C在HTML标准中规定setTimeout低于4ms的时间间隔算为4ms。

（1.5.5）异步http请求线程
（a）XMLHttpRequest在连接后新开一个线程请求


（1.6）GUI渲染线程与JS引擎线程是互斥的原因
js可操作dom元素，如果js操作dom元素同时渲染界面，那么渲染结果不可预期

（1.7）WebWorker
（1.7.1）JS引擎线程的子线程，完全受JS引擎线程控制，且不能操作DOM
（1.7.2）JS引擎线程与WebWorker线程通过postMessage序列化对象通信

（1.8）Renderer进程页面渲染过程
图片

（1.9）setTimeout不能准时执行原因：（1）事件触发线程将其添加到任务队列的队尾，队列前面还有事件未被执行（2）JS引擎未空闲

（1.10）setInterval
（1.10.1）事件触发线程每次隔精确时间将其添加到任务队列的队尾
（1.10.2）累计效应，如果下次setInterval任务已到，本次setInterval任务还没有执行完，就会导致两次任务没有间隔连续执行。
（1.10.3）就算正常间隔执行，两次setInterval任务间隔可能比预期小，因为任务执行需要一段时间
（1.10.4）浏览器最小化时，事件触发线程每次隔精确时间将其添加到任务队列的队尾，浏览器再次打开时，一瞬间全部执行


（1.11）宏任务与微任务与渲染执行顺序
一个宏任务->该宏任务所有微任务->渲染->...



（2）fiber
（2.1）Fiber指一种数据结构，可用一个纯JS对象表示：
const fiber = {
    stateNode,    // 节点实例
    child,        // 子节点
    sibling,      // 兄弟节点
    return,       // 父节点
}

（2.2）React框架内部运作分为3层：
Virtual DOM层：描述页面长什么样。
Reconciler层：调用组件生命周期方法，进行Diff计算。
Renderer层：根据不同的平台，渲染出对应的页面，如ReactDOM和ReactNative。

（2.3）fiber改动主要在Reconciler层，以前Reconciler叫Stack Reconciler，运行过程不能被打断，现在Reconciler叫Fiber Reconciler，运行过程可以被打断，让优先级更高的任务先执行。

（2.4）Fiber Reconciler执行过程中，分为2个阶段。
阶段1：render/reconciliation。生成Fiber树，得出需要更新的节点信息，是一个渐进过程，可以被打断，让优先级更高的任务先执行。包括生命周期
componentWillMount
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
阶段2：commit。将需要更新的节点一次性批量更新，不能被打断。包括生命周期
componentDidMount
componentDidUpdate
componentWillUnmount

（2.5）fiber树
（2.5.1）Fiber Reconciler在阶段1进行Diff计算时，生成一棵Fiber树。该树在Virtual DOM树基础上增加额外信息生成，本质是一个链表。
（2.5.2）Fiber树首次渲染时一次性生成。后续需要Diff时，根据已有树和最新Virtual DOM信息，生成新树。该新树每生成一个新节点，会将控制权交还给JS引擎线程，去检查有没有优先级更高的任务需要执行。如果没有，继续构建Fiber树。如果有，丢弃正在生成的Fiber树，执行优先级更高的任务，执行完后空闲时重新生成Fiber树。


（3）对reac生命周期的影响
（3.1）由于Fiber树的生成机制，Fiber Reconciler阶段1各生命周期可能被重复执行。由于不是纯函数，执行结果不可预测。换成static getDerivedStateFromProps，是纯函数，执行结果可预测。

































































































































































































