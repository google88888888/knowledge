https://zh-hans.reactjs.org/docs/getting-started.html


https://zh-hans.reactjs.org/docs/reconciliation.html
协调

（一）Hello World
（二）JSX 简介
（1）使用{}嵌入单行表达式
（2）引号将属性值指定为字符串字面量
（3）使用camelCase（小驼峰命名）定义属性名，不使用html属性名的命名约定。
（4）类样式class变成了className
（5）如果标签children没有内容，可以使用 /> 闭合标签
（6）插入内容在渲染之前会被转换成了字符串。可以防止 XSS（cross-site-scripting, 跨站脚本）攻击
（7）babel把jsx转译成React.createElement()函数调用，创建 “React 元素”对象。构建dom保持更新

（三）元素渲染
（1）<div id="root"></div>根dom节点内的内容由React DOM管理，渲染用ReactDOM.render(element, document.getElementById('root'));

（四）组件 & Props
（1）分为函数组件和类组件
（2）原生DOM标签名称以小写字母开头，组件名称以大写字母开头
（3）props不能修改

（五）State & 生命周期
（1）可以向类组件实例中添加不参与数据流的自定义类组件实例属性
  componentDidMount() {
    this.timerID = setInterval(
      () => this.doSomething(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

（2）使用
		this.setState({
			key：value,
		});
	更新state
	
（3）性能考虑，React可能把多个setState合并成一个调用

（4）解决this.props和this.state可能异步更新问题：
this.setState((state, props) => ({
  key: state.key + props.key
}));


（六）事件处理
（1）原生DOM事件与React事件区别
（1.1）原生DOM事件名称纯小写，React事件名称小驼峰式（camelCase）
（1.2）原生DOM事件处理函数传入字符串"方法名()"，React事件处理函数传入函数
（1.3）原生DOM事件阻止默认行为可以使用返回false的方式，React事件阻止默认行为不能使用返回false的方式，必须使用e.preventDefault();

（2）js中，class方法默认不会绑定this，绑定方法有：
（2.1） onClick={this.方法名.bind(this)}  
        方法名(){
		}
（2.2） onClick={this.方法名}          class fields 语法
        方法名= () => {
		}
（2.3） onClick={() => this.方法名()}  缺点：每次渲染都会创建不同的回调函数
        方法名(){
		}
（3）传递参数
（3.1） onClick={this.方法名.bind(this,...param)}  
        方法名(...param,e){
		}
（3.2） onClick={this.方法名}          
        方法名= (e) => {
		}
（3.3） onClick={(e) => this.方法名(...param,e)}  
        方法名(...param,e){
		}

（七）条件渲染
（1）使用if
（2）
false或数字0 && expression返回 false
true  && expression返回 expression
（3）condition ? expressionTrue : expressionFalse
（4）render方法return null; 不进行渲染


（八）列表 & Key
（1）数组中项默认用索引做key，应用唯一的字符串做key

（九）表单
（1）受控组件：表单内部state与组件state相结合
      <form onSubmit={this.onSubmit}>
        <input    value={this.state.value} onChange={this.onChange} type="text"   />
        <input type="submit" value="提交" />
      </form>

      其他：
		<textarea value={this.state.value} onChange={this.onChange}    />
        
		<select   value={this.state.value} onChange={this.onChange} >
            <option value="a">a</option>
			<option value="b">b</option>
        </select>

        <select   value={this.state.value} onChange={this.handleChange} multiple={true} >
            <option value="a">a</option>
			<option value="b">b</option>
        </select>
		this.state.value是['a', 'b']形式

（2）非受控组件：表单内部state不与组件state相结合
        <input type="file" />  因其value只读

（十）状态提升：将多个组件中需要共享的state向上移动到它们的最近共同父组件中，实现共享state

（十一）组合vs继承
（1）组件间的渲染内容通过props.children传递进组件
（2）渲染内容也可以通过属性传递进组件

（十二）React 哲学
（十三）无障碍辅助功能
（十四）代码分割
（1）动态导入方法
import("./文件名").then(文件名 => {
    console.log(文件名.文件名中方法名());
});

（2）动态导入组件
（2.1）
import React, { lazy,Suspense } from 'react';
const 组件名 = lazy(() => import('./组件名'));

<Suspense fallback={<div>Loading...</div>}>
    <组件名 />
</Suspense>

（2.2）lazy目前只支持默认导出（default exports）

（十五）Context
（1）
const NameContext = React.createContext(defaultValue);  defaultValue可以是任意数据类型

<NameContext.Provider value={value}>
<该组件及子组件使用距其最近的NameContext.Provider提供的value />
</NameContext.Provider>

使用Object.is检测value变化。value变化时，使用的组件会重渲染且不受制于shouldComponentUpdate

class 该组件及子组件 extends React.Component {
  在方法中通过this.context使用value
}
该组件及子组件.contextType = NameContext;

（2）函数组件和一个组件使用多个context情况使用
<NameContext.Consumer>
  {value => 基于context值进行渲染}
</NameContext.Consumer>

（3）NameContext.displayName=""; React DevTools显示NameContext的名称

（十六）错误边界
（1）错误边界是一种React组件，可以捕获并打印发生在其子组件树任何位置的JavaScript错误，并渲染备用UI
（2）错误边界无法捕获：
（2.1）事件处理（使用try catch捕获）
（2.2）异步代码
（2.3）自身错误
（2.4）服务端渲染

（3）只有class组件中定义getDerivedStateFromError(渲染备用UI)或componentDidCatch(打印错误)至少一个，即为错误边界
（4）自React 16起，未被错误边界捕获的错误会导致整个React组件树被卸载

（十七）Refs 转发
（1）
let 父组件名 = React.forwardRef((props, ref) => {
    return <使用ref ref={ref} />;
});

const ref = React.createRef();
<父组件名 ref={ref}></父组件名>

（2）创建ref后，可通过非ref名的props向子组件传递该ref

（3）
（3.1）return外层默认方法，DevTools中显示ForwardRef
（3.2）return外层name方法，DevTools中显示ForwardRef(name)
（3.3）return外层name方法
       name.displayName="newName"，DevTools中显示ForwardRef(newName)


（十八）Fragments
（1）返回多个同级，外层可用<React.Fragment></React.Fragment>或<> </>
（2）<React.Fragment>只支持key，<>不支持key
       
（十九）高阶组件（HOC）
（1）高阶组件是函数，参数中有组件，返回新组件。解决横切关注点问题
（2）不要在render中使用高阶组件。每次返回新组件，diff算法均判定不同，会卸载原组件并重新挂载新组件，导致状态丢失。

（3）新组件不会有参数中有组件的静态方法。如果要
（3.1）将参数中有组件的静态方法复制到新组件
（3.2）单独导出参数中有组件的静态方法


（十九）与第三方库协同
（1）操作无需更新的React元素，如一个空<div></div>

（二十）深入 JSX
（1）点语法，如antd的<DatePicker.RangePicker></DatePicker.RangePicker>
（2）在运行时选择类型
const component = {
  componentKeyA: ComponentValueA,
  componentKeyB: ComponentValueB,
};
<components["componentKeyA"] />;
错误！JSX 类型不能是一个表达式

const component = {
  componentKeyA: ComponentValueA,
  componentKeyB: ComponentValueB,
};
const Component = components["componentKeyA"];
<Component />;
正确！JSX 类型可以是大写字母开头的变量

（3）字符串字面量赋值给props时，值未转义。下面相等
<Component propsName="&lt;&gt;" />
<Component propsName={'<>'}     />

（4）props默认值为True。下面相等
<Component propsName        />
<Component propsName={true} />

（5）props属性展开
<Component {...props} />

（6）布尔类型、Null、Undefined会忽略。下面相等
<div></div>
<div>{true}</div>
<div>{false}</div>
<div>{null}</div>
<div>{undefined}</div>


（二十一）性能优化
（1）计算某组件是否重渲染，顺序：
（1.1）shouldComponentUpdate返回false该组件及子组件不重新渲染
（1.2）shouldComponentUpdate返回true，虚拟dom相同，该组件及子组件不重新渲染
（1.3）shouldComponentUpdate返回true，虚拟dom不同，该组件重新渲染，计算子组件是否重渲染

（2）shouldComponentUpdate默认返回true
（3）React.PureComponent浅比较当前与之前props与state实现shouldComponentUpdate
（4）浅比较为引用相等，深比较为原值相等

（二十二）Portals
（1）ReactDOM.createPortal(component, container) 将子组件渲染到父组件外的DOM节点
（2）portal表现在DOM树，结构在React树，其行为与普通子组件行为一致

（二十三）Profiler 
（1）Profiler能放在React树中的任何地方测量这部分渲染带来的开销，需要两个props
<Profiler id="id" onRender={onRender}>
    <Component />
</Profiler>

（二十四）不使用 ES6
（二十五）不使用 JSX
（二十六）协调






























































































































































